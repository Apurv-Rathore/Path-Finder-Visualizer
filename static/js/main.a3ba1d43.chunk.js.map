{"version":3,"sources":["helper functions/nodesInShortestPath.jsx","PathFindingVisual/Node/Node.jsx","algorithms/bfs.jsx","algorithms/dfs.jsx","Heuristic/manhattan.jsx","Heuristic/chebyshev.jsx","Heuristic/octile.jsx","Heuristic/euclidean.jsx","algorithms/astar.jsx","Maze/randomMazeGen.jsx","Maze/verticalMaze.jsx","Maze/recursiveDivision.jsx","PathFindingVisual/PathFinding.jsx","App.js","reportWebVitals.js","index.js"],"names":["nodesInShortestPath","parent","START_ROW","START_COL","END_ROW","END_COLUMN","end_row","end_col","nodesInShortestPathOrder","push","reverse","console","log","Node","props","state","this","isFinish","isStart","inPath","inPathFirst","inShortestPath","isWall","onMouseDown","onMouseEnter","onMouseUp","row","col","direction","extraClassName","arrowClassName","className","Component","Queue","items","element","length","shift","bfs","grid","NUMBER_OF_COL","NUMBER_OF_ROW","visitedNodesInOrder","visited","currentRow","queue","enqueue","isEmpty","front","dequeue","x","y","dfs","stack","topStack","pop","manhattan","END_COL","CUR_ROW","CUR_COL","Math","abs","chebyshev","dy","dx","max","octile","min","euclidean","pow","heuristic","currentHeuristic","QueueElement","priority","PriorityQueue","queueElement","added","i","splice","str","astar","cameFrom","vis","gScore","fScore","visitedNodes","goal","minFScoreNode","newx","newy","tent_score","randomMaze","newGrid","slice","walls","random","sort","randomNumber","floor","verticalMaze","rec","vertical","horizontal","number","generateOddRandomNumber","addWall","indexOf","dir","num","isStartFinish","tempWalls","temp","randomNum","generateRandomNumber","wall","undefined","array","recursiveDivision","PathFinding","displayMsg","setState","msgDisplay","msgOpacity","setTimeout","resetGrid","getInitialGrid","drawArrows","visualizeAlgo","clearPath","tempGrid","prevTime","performance","now","currentAlgo","alert","finalTime","timeTaken","animateAlgo","generateMaze","currentMaze","mouseIsPressed","mousePressedTarget","mousePressedSource","getNewGridWithWallToggled","getNewGridWithTargetChanged","getNewGridWithSourceChanged","algo","animateShortestPath","node","style","marginBottom","Navbar","fontSize","collapseOnSelect","expand","bg","variant","Brand","href","Nav","Link","onClick","Button","Toggle","aria-controls","Collapse","id","NavDropdown","title","Item","map","rowIdx","nodeIdx","handleMouseUp","handleMouseDown","handleMouseEnter","class","display","opacity","isClearPath","gridArg","resetWall","isVisited","previousNode","createNode","distance","Infinity","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"qTA+BeA,EA/Ba,SAC1BC,EACAC,EACAC,EACAC,EACAC,GAQA,IAHA,IAAIC,EAAUF,EACVG,EAAUF,EACVG,EAA2B,GACxBF,IAAYJ,GAAaK,IAAYJ,GAC1CK,EAAyBC,KAAK,CAACH,EAASC,IACR,KAA5BN,EAAOK,GAASC,GAClBD,GAAW,EAC0B,KAA5BL,EAAOK,GAASC,GACzBD,GAAW,EAC0B,KAA5BL,EAAOK,GAASC,GACzBA,GAAW,EAEXA,GAAW,EAMf,OAHAC,EAAyBC,KAAK,CAACH,EAASC,IACxCC,EAAyBE,UACzBC,QAAQC,IAAIJ,GACLA,G,mECzBYK,E,kDACnB,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,GAFI,E,0CAOnB,WACE,MAYIC,KAAKF,MAXPG,EADF,EACEA,SACAC,EAFF,EAEEA,QACAC,EAHF,EAGEA,OACAC,EAJF,EAIEA,YACAC,EALF,EAKEA,eACAC,EANF,EAMEA,OACAC,EAPF,EAOEA,YACAC,EARF,EAQEA,aACAC,EATF,EASEA,UACAC,EAVF,EAUEA,IAAIC,EAVN,EAUMA,IACJC,EAXF,EAWEA,UAGEC,EAAiB,GACjBC,EAAiB,GAmCrB,OA7BIX,IACFU,EAAiB,UAEfT,IACFS,EAAiB,eAEfR,IACFQ,EAAiB,iBACF,KAAXD,IACFE,EAAiB,QAEJ,KAAXF,IACFE,EAAiB,MAEJ,KAAXF,IACFE,EAAiB,SAEJ,KAAXF,IACFE,EAAiB,SAGjBb,EACAY,EAAiB,WACVX,IACPW,EAAiB,WAEjBP,IACFO,EAAiB,UAEZ,qBAAKN,YAAa,kBAAMA,EAAYG,EAAKC,IAChDH,aAAc,kBAAMA,EAAaE,EAAKC,IAEtCF,UAAW,kBAAMA,KAAaM,UAAS,eAAUF,EAAV,YAA4BC,GAH5D,SAIL,qBAAKC,UAAS,WAAMD,W,GA/DQE,aCH5BC,G,iBACJ,aAAe,oBACbjB,KAAKkB,MAAQ,G,2CAIf,SAAQC,GACN,OAAOnB,KAAKkB,MAAMzB,KAAK0B,K,qBAIzB,WACE,GAAInB,KAAKkB,MAAME,OAAS,EACtB,OAAOpB,KAAKkB,MAAMG,U,qBAKtB,WACE,OAA6B,IAAtBrB,KAAKkB,MAAME,S,mBAIpB,WACEpB,KAAKkB,MAAQ,O,MA4FFI,EAzFH,SAACpC,EAAWC,EAAWC,EAASC,EAAYkC,EAAKC,EAAcC,GAOzE,IAJA,IAAIC,EAAsB,GAGtBC,EAAU,GACLjB,EAAM,EAAGA,EAAMe,EAAef,IAAO,CAE5C,IADA,IAAMkB,EAAa,GACVjB,EAAM,EAAGA,EAAMa,EAAeb,IACrCiB,EAAWnC,MAAK,GAElBkC,EAAQlC,KAAKmC,GAKf,IADA,IAAI3C,EAAS,GACJyB,EAAM,EAAGA,EAAMe,EAAc,EAAGf,IAAO,CAE9C,IADA,IAAMkB,EAAa,GACVjB,EAAM,EAAGA,EAAMa,EAAc,EAAGb,IACvCiB,EAAWnC,KAAK,KAElBR,EAAOQ,KAAKmC,GAId,IAAIC,EAAQ,IAAIZ,EAGhB,IAFAY,EAAMC,QAAQ,CAAC5C,EAAWC,IAC1BwC,EAAQzC,GAAWC,IAAa,EACN,GAAnB0C,EAAME,WAAoB,CAC/B,IAAMC,EAAQH,EAAMI,UAChBC,EAAIF,EAAM,GACVG,EAAIH,EAAM,GAEd,GADAN,EAAoBjC,KAAK,CAACyC,EAAGC,IACzBD,GAAK9C,GAAW+C,GAAK9C,EACvB,MAAO,CAAEJ,SAAQyC,uBAEfQ,EAAI,EAAIT,IAGe,GAArBF,EAFJW,GAAK,GAEOC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KACbR,EAAQO,GAAGC,IAAK,EAChBlD,EAAOiD,GAAGC,GAAK,IACfN,EAAMC,QAAQ,CAACI,EAAGC,KAGtBD,GAAK,GAEHA,EAAI,IAGmB,GAArBX,EAFJW,GAAK,GAEOC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KACbR,EAAQO,GAAGC,IAAK,EAChBlD,EAAOiD,GAAGC,GAAK,IACfN,EAAMC,QAAQ,CAACI,EAAGC,KAGtBD,GAAK,GAEHC,EAAI,EAAIX,IACVW,GAAK,EAEoB,GAArBZ,EAAKW,GAAGC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KACbR,EAAQO,GAAGC,IAAK,EAChBlD,EAAOiD,GAAGC,GAAK,IACfN,EAAMC,QAAQ,CAACI,EAAGC,KAGtBA,GAAK,GAEHA,EAAI,IACNA,GAAK,EAEoB,GAArBZ,EAAKW,GAAGC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KACbR,EAAQO,GAAGC,IAAK,EAChBlD,EAAOiD,GAAGC,GAAK,IACfN,EAAMC,QAAQ,CAACI,EAAGC,KAGtBA,GAAK,GAGT,MAAO,CAAElD,QAAQ,EAAGyC,wBCbPU,EApGH,SACVlD,EACAC,EACAC,EACAC,EACAkC,EACAC,EACAC,GAQA,IAJA,IAAIC,EAAsB,GAGtBC,EAAU,GACLjB,EAAM,EAAGA,GAAOe,EAAef,IAAO,CAE7C,IADA,IAAMkB,EAAa,GACVjB,EAAM,EAAGA,GAAOa,EAAeb,IACtCiB,EAAWnC,MAAK,GAElBkC,EAAQlC,KAAKmC,GAKf,IADA,IAAI3C,EAAS,GACJyB,EAAM,EAAGA,EAAMe,EAAgB,EAAGf,IAAO,CAEhD,IADA,IAAMkB,EAAa,GACVjB,EAAM,EAAGA,EAAMa,EAAgB,EAAGb,IACzCiB,EAAWnC,KAAK,KAElBR,EAAOQ,KAAKmC,GAKd,IAAIS,EAAQ,GAIZ,IAFAA,EAAM5C,KAAK,CAACP,EAAWC,IAEC,IAAjBkD,EAAMjB,QAAc,CACzB,IAAMkB,EAAWD,EAAME,MACnBL,EAAII,EAAS,GACbH,EAAIG,EAAS,GAKjB,GAHAX,EAAQO,GAAGC,IAAK,EAChBT,EAAoBjC,KAAK,CAACyC,EAAGC,IAEzBD,GAAK9C,GAAW+C,GAAK9C,EACvB,MAAO,CAAEJ,SAAQyC,uBAGfS,EAAI,IACNA,GAAK,EACoB,GAArBZ,EAAKW,GAAGC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KAEblD,EAAOiD,GAAGC,GAAK,IACfE,EAAM5C,KAAK,CAACyC,EAAGC,KAGnBA,GAAK,GAGHD,EAAI,EAAIT,IAEe,GAArBF,EADJW,GAAK,GACOC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KAEblD,EAAOiD,GAAGC,GAAK,IACfE,EAAM5C,KAAK,CAACyC,EAAGC,KAGnBD,GAAK,GAGHC,EAAI,EAAIX,IACVW,GAAK,EACoB,GAArBZ,EAAKW,GAAGC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KAEblD,EAAOiD,GAAGC,GAAK,IACfE,EAAM5C,KAAK,CAACyC,EAAGC,KAGnBA,GAAK,GAEHD,EAAI,IAEmB,GAArBX,EADJW,GAAK,GACOC,GAAG7B,QACQ,GAAjBqB,EAAQO,GAAGC,KAEblD,EAAOiD,GAAGC,GAAK,IACfE,EAAM5C,KAAK,CAACyC,EAAGC,KAGnBD,GAAK,GAGT,MAAO,CAAEjD,QAAS,EAAGyC,wBC7FRc,EALG,SAACpD,EAASqD,EAASC,EAASC,GAC1C,OAAOC,KAAKC,IAAIJ,EAAUE,GAAWC,KAAKC,IAAIzD,EAAUsD,ICO7CI,EARG,SAAC1D,EAASqD,EAASC,EAASC,GAC1C,IAAMI,EAAKH,KAAKC,IAAIJ,EAAQE,GACtBK,EAAKJ,KAAKC,IAAIzD,EAAQsD,GAE5B,OADiBE,KAAKK,IAAIF,EAAGC,ICKlBE,EARA,SAAC9D,EAASqD,EAASC,EAASC,GACvC,IAAMI,EAAKH,KAAKC,IAAIJ,EAAQE,GACtBK,EAAKJ,KAAKC,IAAIzD,EAAQsD,GAE5B,OADiB,MAASE,KAAKO,IAAIH,EAAGD,GAAOH,KAAKC,IAAIG,EAAGD,ICM9CK,EATG,SAAChE,EAASqD,EAASC,EAASC,GAC1C,IAAMT,EAAIU,KAAKC,IAAIzD,EAAQsD,GAASE,KAAKC,IAAIzD,EAAQsD,GAC/CP,EAAIS,KAAKC,IAAIJ,EAAQE,GAASC,KAAKC,IAAIJ,EAAQE,GAErD,OADUC,KAAKS,IAAInB,EAAEC,EAAE,KCGrBmB,EAAY,SAAClE,EAASqD,EAASC,EAASC,EAASY,GAGrD,MAAwB,aAApBA,EAEWf,EAAUpD,EAASqD,EAASC,EAASC,GAI5B,aAApBY,EACKT,EAAU1D,EAASqD,EAASC,EAASC,GAEtB,UAApBY,EACKL,EAAO9D,EAASqD,EAASC,EAASC,GAEnB,aAApBY,EACKH,EAAUhE,EAASqD,EAASC,EAASC,QAD9C,GAiBIa,EACJ,WAAYrC,EAASsC,GAAW,oBAC9BzD,KAAKmB,QAAUA,EACfnB,KAAKyD,SAAWA,GAIdC,E,WACJ,aAAe,oBACb1D,KAAKkB,MAAQ,G,2CAGf,SAAQC,EAASsC,GAGf,IAFA,IAAIE,EAAe,IAAIH,EAAarC,EAASsC,GACzCG,GAAQ,EACHC,EAAI,EAAGA,EAAI7D,KAAKkB,MAAME,OAAQyC,IACrC,GAAIF,EAAaF,SAAWzD,KAAKkB,MAAM2C,GAAGJ,SAAU,CAClDzD,KAAKkB,MAAM4C,OAAOD,EAAG,EAAGF,GACxBC,GAAQ,EACR,MAGCA,GACH5D,KAAKkB,MAAMzB,KAAKkE,K,qBAGpB,WACE,OAAO3D,KAAKkB,MAAMG,U,qBAGpB,WACE,OAA0B,IAAtBrB,KAAKkB,MAAME,S,yBAIjB,WAEE,IADA,IAAI2C,EAAM,GACDF,EAAI,EAAGA,EAAI7D,KAAKkB,MAAME,OAAQyC,IACrCE,GAAO/D,KAAKkB,MAAM2C,GAAG1C,QAAU,IACjC,OAAO4C,M,KAyLIC,EAjLD,SACZ9E,EACAC,EACAC,EACAC,EACAkC,EACAC,EACAC,EACA8B,GAKA,IAHA,IAAI1B,EAAQ,IAAI6B,EACZO,EAAW,GACXC,EAAM,GACDxD,EAAM,EAAGA,EAAMe,EAAef,IAAO,CAE5C,IADA,IAAIkB,EAAa,GACRjB,EAAM,EAAGA,EAAMa,EAAeb,IACrCiB,EAAWnC,MAAK,GAElByE,EAAIzE,KAAKmC,GAIX,IADA,IAAI3C,EAAS,GACJyB,EAAM,EAAGA,EAAMe,EAAgB,EAAGf,IAAO,CAEhD,IADA,IAAMkB,EAAa,GACVjB,EAAM,EAAGA,EAAMa,EAAgB,EAAGb,IACzCiB,EAAWnC,KAAK,KAElBR,EAAOQ,KAAKmC,GAId,IADA,IAAIuC,EAAS,GACJzD,EAAM,EAAGA,EAAMe,EAAef,IAAO,CAE5C,IADA,IAAIkB,EAAa,GACRjB,EAAM,EAAGA,EAAMa,EAAeb,IACrCiB,EAAWnC,KAAK,KAElB0E,EAAO1E,KAAKmC,GAEduC,EAAOjF,GAAWC,GAAa,EAG/B,IADA,IAAIiF,EAAS,GACJ1D,EAAM,EAAGA,EAAMe,EAAef,IAAO,CAE5C,IADA,IAAIkB,EAAa,GACRjB,EAAM,EAAGA,EAAMa,EAAeb,IACrCiB,EAAWnC,KAAK,KAElB2E,EAAO3E,KAAKmC,GAGdwC,EAAOlF,GAAWC,GAAamE,EAC7BlE,EACAC,EACAH,EACAC,EACAoE,GAIF,IAAIc,EAAe,GACnBxC,EAAMC,QAAQ,CAAC5C,EAAWC,GAAYiF,EAAOlF,GAAWC,IACxD+E,EAAIhF,GAAWC,IAAa,EAG5B,IAFA,IAAMmF,EAAO,CAAClF,EAASC,IAEI,IAApBwC,EAAME,WAAqB,CAEhC,IAAIwC,EAAgB1C,EAAMI,UAAUd,QAGpC,GAAImD,EAAK,KAAOC,EAAc,IAAMD,EAAK,KAAOC,EAAc,GAI5D,OAFA5E,QAAQC,IAAIqE,GAEL,CAAEhF,SAAQoF,gBAEnB,IAAMnC,EAAIqC,EAAc,GAClBpC,EAAIoC,EAAc,GACxBF,EAAa5E,KAAK,CAACyC,EAAGC,IACtB,IAAIqC,EAAOtC,EAAI,EACXuC,EAAOtC,EACX,GAAIqC,EAAO/C,GACsB,GAA3BF,EAAKiD,GAAMC,GAAMnE,OAAiB,CACpC,IAAMoE,EAAaP,EAAOjC,GAAGC,GAAK,EAE9BuC,EAAaP,EAAOK,GAAMC,KAC5BR,EAAS,CAACO,EAAMC,IAAS,CAACvC,EAAGC,GAC7BgC,EAAOK,GAAMC,GAAQC,EACrBN,EAAOI,GAAMC,GACXN,EAAOK,GAAMC,GAAQnB,EAAUlE,EAASC,EAAYmF,EAAMC,EAAKlB,IACzC,IAApBW,EAAIM,GAAMC,KACZP,EAAIM,GAAMC,IAAQ,EAClBxF,EAAOuF,GAAMC,GAAQ,IACrB5C,EAAMC,QAAQ,CAAC0C,EAAMC,GAAOL,EAAOI,GAAMC,MAUjD,GADAA,EAAOtC,GADPqC,EAAOtC,EAAI,IAEC,GACqB,GAA3BX,EAAKiD,GAAMC,GAAMnE,OAAiB,CACpC,IAAMoE,EAAaP,EAAOjC,GAAGC,GAAK,EAC9BuC,EAAaP,EAAOK,GAAMC,KAC5BR,EAAS,CAACO,EAAMC,IAAS,CAACvC,EAAGC,GAC7BgC,EAAOK,GAAMC,GAAQC,EACrBN,EAAOI,GAAMC,GACXN,EAAOK,GAAMC,GAAQnB,EAAUlE,EAASC,EAAYmF,EAAMC,IACpC,IAApBP,EAAIM,GAAMC,KACZP,EAAIM,GAAMC,IAAQ,EAClBxF,EAAOuF,GAAMC,GAAQ,IACrB5C,EAAMC,QAAQ,CAAC0C,EAAMC,GAAOL,EAAOI,GAAMC,MAQjD,GAFAD,EAAOtC,GACPuC,EAAOtC,EAAI,IACC,GACqB,GAA3BZ,EAAKiD,GAAMC,GAAMnE,OAAiB,CACpC,IAAMoE,EAAaP,EAAOjC,GAAGC,GAAK,EAC9BuC,EAAaP,EAAOK,GAAMC,KAC5BR,EAAS,CAACO,EAAMC,IAAS,CAACvC,EAAGC,GAC7BgC,EAAOK,GAAMC,GAAQC,EACrBN,EAAOI,GAAMC,GACXN,EAAOK,GAAMC,GAAQnB,EAAUlE,EAASC,EAAYmF,EAAMC,IACpC,IAApBP,EAAIM,GAAMC,KACZP,EAAIM,GAAMC,IAAQ,EAClBxF,EAAOuF,GAAMC,GAAQ,IACrB5C,EAAMC,QAAQ,CAAC0C,EAAMC,GAAOL,EAAOI,GAAMC,MAQjD,GAFAD,EAAOtC,GACPuC,EAAOtC,EAAI,GACAX,GACsB,GAA3BD,EAAKiD,GAAMC,GAAMnE,OAAiB,CACpC,IAAMoE,EAAaP,EAAOjC,GAAGC,GAAK,EAC9BuC,EAAaP,EAAOK,GAAMC,KAC5BR,EAAS,CAACO,EAAMC,IAAS,CAACvC,EAAGC,GAC7BgC,EAAOK,GAAMC,GAAQC,EACrBN,EAAOI,GAAMC,GACXN,EAAOK,GAAMC,GAAQnB,EAAUlE,EAASC,EAAYmF,EAAMC,EAAKlB,IACzC,IAApBW,EAAIM,GAAMC,KACZP,EAAIM,GAAMC,IAAQ,EAClBxF,EAAOuF,GAAMC,GAAQ,IACrB5C,EAAMC,QAAQ,CAAC0C,EAAMC,GAAOL,EAAOI,GAAMC,OAcnD,MAAO,CAAExF,QAAS,EAAGoF,iBCnORM,MAtBf,SAAoBpD,EAAKrC,EAAUC,EAAYC,EAASqD,EAAQhB,EAAcD,GAM5E,IAFA,IAAIoD,EAAUrD,EAAKsD,QACfC,EAAQ,GACHpE,EAAM,EAAGA,EAAMe,EAAef,IACrC,IAAK,IAAIC,EAAM,EAAGA,EAAMa,EAAeb,IAElCD,IAAQxB,GAAayB,IAAQxB,GAC7BuB,IAAQtB,GAAWuB,IAAQ8B,GAG1BG,KAAKmC,SAAW,MAClBD,EAAMrF,KAAK,CAACiB,EAAKC,IACjBiE,EAAQlE,GAAKC,GAAKL,QAAS,GAKjC,OADAwE,EAAME,MAAK,kBAAMpC,KAAKmC,SAAW,MAC1B,CAACD,QAAOF,YCpBjB,SAASK,EAAa9B,EAAKF,GACvB,OAAOL,KAAKsC,MAAMtC,KAAKmC,UAAY9B,EAAME,GAAOA,GAGpD,ICFI2B,EDyDWK,EAvDM,SAAC5D,EAAKrC,EAAUC,EAAYC,EAASqD,EAAQhB,EAAcD,GAE5E,IADA,IAAIoD,EAAUrD,EAAKsD,QACVnE,EAAM,EAAGA,EAAMe,EAAef,KAC/BA,GAAKxB,GAAc,GAAGC,GAAaA,GAAWqC,EAAc,KAC5Dd,GAAKtB,GAAY,GAAGqD,GAAWA,GAASjB,EAAc,KAC1DoD,EAAQlE,GAAK,GAAGJ,QAAS,EACzBsE,EAAQlE,GAAKc,EAAc,GAAGlB,QAAS,GAE3C,IAAK,IAAIK,EAAM,EAAGA,EAAMa,EAAeb,KAC/BA,GAAKxB,GAAc,GAAGD,GAAaA,GAAWuC,EAAc,KAC5Dd,GAAK8B,GAAY,GAAGrD,GAAWA,GAAUqC,EAAc,KAC3DmD,EAAQ,GAAGjE,GAAKL,QAAO,EACvBsE,EAAQnD,EAAc,GAAGd,GAAKL,QAAO,GAEzC,IAAK,IAAII,EAAI,EAAEA,EAAIe,EAAcf,IAE7B,GAAIA,EAAI,IAAI,EAAZ,CACA,IAAIqE,EAASE,EAAa,EAAEzD,GAC5B,GAAId,IAAMxB,GAAawB,IAAMtB,EAAQ,CACjC,GAAIF,IAAYE,EAAQ,CACpB,IAAK,IAAIuB,EAAI,EAAEA,EAAIa,EAAcb,IACzBA,IAAMxB,GAAawB,IAAM8B,IAEzBmC,EAAQlE,GAAKC,GAAKL,QAAS,GAInC,SAEJ,KAAMyE,IAAS5F,GAAa4F,IAAStC,GACjCsC,EAASE,EAAa,EAAEzD,GAchC,IAAK,IAAIb,EAAI,EAAEA,EAAIa,EAAcb,IACzBA,IAAMoE,IAENH,EAAQlE,GAAKC,GAAKL,QAAS,GAKvC,OAAOsE,G,QCnBX,IAAMQ,EAAM,SAANA,EACJC,EACAC,EACA/D,EACArC,EACAC,EACAC,EACAqD,GAEA,KAAI4C,EAASjE,OAAS,GAAKkE,EAAWlE,OAAS,GAA/C,CAGA,IAAIR,EAAY,EACZ2E,EAAS,EACTF,EAASjE,OAASkE,EAAWlE,QAC/BR,EAAY,EACZ2E,EAASC,EAAwBH,KAEjCzE,EAAY,EACZ2E,EAASC,EAAwBF,IAEjB,IAAd1E,GACF6E,EAAQ7E,EAAW2E,EAAOhE,EAAM8D,EAAUC,EAAapG,EAAWC,EAAWC,EAASqD,GACtF2C,EACEC,EAASR,MAAM,EAAGQ,EAASK,QAAQH,IACnCD,EACA/D,EACArC,EAAWC,EAAWC,EAASqD,GAEjC2C,EACEC,EAASR,MAAMQ,EAASK,QAAQH,GAAU,GAC1CD,EACA/D,EACArC,EAAWC,EAAWC,EAASqD,KAIjCgD,EAAQ7E,EAAW2E,EAAOhE,EAAM8D,EAAUC,EAAYpG,EAAWC,EAAWC,EAASqD,GACrF2C,EACEC,EACAC,EAAWT,MAAM,EAAGS,EAAWI,QAAQH,IACvChE,EACArC,EAAWC,EAAWC,EAASqD,GAEjC2C,EACEC,EACAC,EAAWT,MAAMS,EAAWI,QAAQH,GAAU,GAC9ChE,EACArC,EAAWC,EAAWC,EAASqD,MAKrC,SAASgD,EAAQE,EAAKC,EAAIrE,EAAM8D,EAAUC,EAAYpG,EAAWC,EAAWC,EAASqD,GACnF,IAAIoD,GAAgB,EAChBC,EAAY,GAChB,GAAY,IAARH,EAAW,CACb,GAA0B,IAAtBL,EAAWlE,OAAc,OADhB,oBAEIkE,GAFJ,IAEb,2BAA6B,CAAC,IAArBS,EAAoB,QAExBA,IAAS7G,GAAa0G,IAAQzG,GAC9B4G,IAAS3G,GAAWwG,IAAQnD,EAE7BoD,GAAgB,EAGlBC,EAAUrG,KAAK,CAACsG,EAAMH,KAVX,mCAYR,CACL,GAAwB,IAApBP,EAASjE,OAAc,OADtB,oBAEYiE,GAFZ,IAEL,2BAA2B,CAAC,IAAnBU,EAAkB,QAEtBA,IAAS7G,GAAa0G,IAAQzG,GAC9B4G,IAAS3G,GAAWwG,IAAQnD,EAE7BoD,GAAgB,EAGlBC,EAAUrG,KAAK,CAACmG,EAAKG,KAVlB,+BAaFF,GACHC,EAAUhC,OAYd,SAA8Bb,GAC5B,IAAI+C,EACFpD,KAAKsC,MAAMtC,KAAKmC,UAAY9B,EAAM,IAClCL,KAAKsC,MAAMtC,KAAKmC,UAAY9B,EAAM,IAChC+C,EAAY,IAAM,IAChBA,IAAc/C,EAChB+C,GAAa,EAEbA,GAAa,GAGjB,OAAOA,EAvBYC,CAAqBH,EAAU1E,QAAS,GAE3D,cAAiB0E,EAAjB,eAA4B,CAAvB,IAAII,EAAI,KACXpB,EAAMrF,KAAKyG,QACDC,GAAND,IAIJ3E,EAAK2E,EAAK,IAAIA,EAAK,IAAI5F,QAAS,IAiBpC,SAASkF,EAAwBY,GAC/B,IAAInD,EAAMmD,EAAMhF,OAAS,EACrB4E,EACFpD,KAAKsC,MAAMtC,KAAKmC,UAAY9B,EAAM,IAClCL,KAAKsC,MAAMtC,KAAKmC,UAAY9B,EAAM,IAQpC,OAPI+C,EAAY,IAAM,IAChBA,IAAc/C,EAChB+C,GAAa,EAEbA,GAAa,GAGVI,EAAMJ,GAGAK,MA5Jf,SACE9E,EACArC,EACAC,EACAC,EACAqD,EACAhB,EACAD,GAKA,IAHA,IAAI6D,EAAW,GACXC,EAAa,GAER5E,EAAM,EAAGA,EAAMa,EAAKH,OAAQV,IAAO4E,EAAW7F,KAAKiB,GAC5D,IAAK,IAAIC,EAAM,EAAGA,EAAMY,EAAK,GAAGH,OAAQT,IAAO0E,EAAS5F,KAAKkB,GAC7D,IAAK,IAAID,EAAM,EAAGA,EAAMe,EAAef,KACjCA,GAAKxB,GAAc,GAAGC,GAAaA,GAAWqC,EAAc,KAC5Dd,GAAKtB,GAAY,GAAGqD,GAAWA,GAASjB,EAAc,KAC1DD,EAAKb,GAAK,GAAGJ,QAAS,EACtBiB,EAAKb,GAAKc,EAAc,GAAGlB,QAAS,GAExC,IAAK,IAAIK,EAAM,EAAGA,EAAMa,EAAeb,KAC/BA,GAAKxB,GAAc,GAAGD,GAAaA,GAAWuC,EAAc,KAC5Dd,GAAK8B,GAAY,GAAGrD,GAAWA,GAAUqC,EAAc,KAC3DF,EAAK,GAAGZ,GAAKL,QAAO,EACpBiB,EAAKE,EAAc,GAAGd,GAAKL,QAAO,GAOpC,OALFkB,GAAe,EACfC,GAAe,EACbqD,EAAQ,GACRM,EAAIC,EAAUC,EAAY/D,EAAMrC,EAAWC,EAAWC,EAASqD,GAC/D9C,QAAQC,IAAI,OAAO2B,GACZA,GCZLrC,EAAY,GACZC,EAAY,GACZC,EAAU,GACVC,EAAa,GAEXoC,EAAgB,GAChBD,EAAgB,GAED8E,E,kDACnB,WAAYxG,GAAQ,IAAD,8BACjB,cAAMA,IA6ERyG,WAAa,WAEX,EAAKC,SAAS,CAACC,WAAW,QAASC,WAAW,IAC9CC,YAAW,WACT,EAAKH,SAAS,CAACC,WAAW,OAAQC,WAAW,MAC7C,MAnFe,EAkJnBE,UAAY,WACV,IAAMrF,EAAOsF,GAAe,EAAO,IAAG,GACtC,EAAKL,SAAS,CAAEjF,UApJC,EAuJnBuF,WAAa,SAAC7H,GAIZ,IAFA,IAAIK,EAAUF,EACVG,EAAUF,EACPC,IAAYJ,GAAaK,IAAYJ,GAK1C,GAAgC,KAA5BF,EAAOK,GAASC,GAAiB,CAEnC,GADAD,GAAW,EACPC,IAAYJ,GAAaG,IAAYJ,EACvC,MAEF,IAAI0F,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASqB,UAAY,IACtC,EAAK4F,SAAS,CAAE5B,iBACX,GAAgC,KAA5B3F,EAAOK,GAASC,GAAiB,CAE1C,GADAD,GAAW,EACPC,IAAYJ,GAAaG,IAAYJ,EACvC,MAEF,IAAI0F,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASqB,UAAY,IACtC,EAAK4F,SAAS,CAAE5B,iBACX,GAAgC,KAA5B3F,EAAOK,GAASC,GAAiB,CAE1C,IADAA,GAAW,KACKJ,GAAaG,IAAYJ,EACvC,MAEF,IAAI0F,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASqB,UAAY,IACtC,EAAK4F,SAAS,CAAE5B,gBACX,CAEL,IADArF,GAAW,KACKJ,GAAaG,IAAYJ,EACvC,MAEF,IAAI0F,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASqB,UAAY,IACtC,EAAK4F,SAAS,CAAE5B,cA/LH,EAoMnB3F,QAAU,EApMS,EAqMnB8H,cAAgB,WACd,EAAKC,YACL,IAAIC,EAAW,EAAKlH,MAAMwB,KAC1B0F,EAAS/H,GAAWC,GAAWmB,QAAO,EACtC2G,EAAS7H,GAASC,GAAYiB,QAAO,EACrC,IAAM4G,EAAWC,YAAYC,MAC7B,GAA+B,UAA3B,EAAKrH,MAAMsH,YAAyB,CAEtCC,MAAM,kBACN,IAAM/D,EAAmB,EAAKxD,MAAMwD,iBACpC,EAAiCS,EAC/B9E,EACAC,EACAC,EACAC,EACA,EAAKU,MAAMwB,KACXC,EACAC,EACA8B,GARMtE,EAAR,EAAQA,OAAQoF,EAAhB,EAAgBA,aAUVkD,EAAYJ,YAAYC,MAC9B,EAAKZ,SAAS,CAACgB,UAAWD,EAAUL,IACpCvH,QAAQC,IAAIX,GACZ,IAAIO,EAA2B,GAC/BG,QAAQC,IAAIX,IACI,IAAZA,QAA2BkH,GAAVlH,IACnBO,EAA2BR,EACzBC,EACAC,EACAC,EACAC,EACAC,GAEF,EAAKyH,WAAW7H,IAElB,EAAKwI,YAAYpD,EAAc7E,EAA0B,OAE3D,GAA8B,OAA1B,EAAKO,MAAMsH,YAAsB,CAGnC,MAAsC/F,EACpCpC,EACAC,EACAC,EACAC,EACA,EAAKU,MAAMwB,KACXC,EACAC,GAPIxC,EAAN,EAAMA,OAAQyC,EAAd,EAAcA,oBAUR6F,EAAYJ,YAAYC,MAC9B,EAAKZ,SAAS,CAACgB,UAAWD,EAAUL,IACpC,IAAI1H,GAA4B,GAChB,IAAZP,IACFO,EAA2BR,EACzBC,EACAC,EACAC,EACAC,EACAC,GAEF,EAAKyH,WAAW7H,IAElB,EAAKwI,YAAY/F,EAAqBlC,EAA0B,YAC3D,GAA+B,QAA3B,EAAKO,MAAMsH,YAAuB,CAC3C1H,QAAQC,IAAI,UACZ,MAAsCwC,EACpClD,EACAC,EACAC,EACAC,EACA,EAAKU,MAAMwB,KACXC,EACAC,GAPIxC,EAAN,EAAMA,OAAQyC,EAAd,EAAcA,oBASR6F,EAAYJ,YAAYC,MAC9B,EAAKZ,SAAS,CAACgB,UAAWD,EAAUL,KAGpB,IAAZjI,IACyBD,EACzBC,EACAC,EACAC,EACAC,EACAC,GAEF,EAAKyH,WAAW7H,IAElB,EAAKwI,YAAY/F,EAAqBA,EAAqB,SA9R5C,EAkSnBsF,UAAY,WACV,EAAKR,SAAS,CAAEjF,KAAMsF,GAAe,EAAM,EAAK9G,MAAMwB,MAAK,MAnS1C,EAsSnBmG,aAAe,SAACC,GACd,IAAIV,EAAW,EAAKlH,MAAMwB,KAa1B,GAZA0F,EAAS/H,GAAWC,GAAWe,SAAU,EAEzCf,EAAY,EACZ8H,EAFA/H,EAAY,GAEQC,GAAWe,SAAU,EACzC+G,EAAS7H,GAASC,GAAYY,UAAS,EACvCZ,EAAamC,GAEbyF,EADA7H,EAAUqC,IACQpC,GAAYY,UAAS,EACvC,EAAKuG,SAAS,CAACjF,KAAK0F,IACpB,EAAKT,SAAS,CAAEjF,KAAMsF,GAAe,EAAM,EAAK9G,MAAMwB,MAAK,KAGzC,WAAdoG,EAAuB,CACzB,IAAM/C,EAAUyB,EAAkB,EAAKtG,MAAMwB,KAAKrC,EAAUC,EAAYC,EAASC,EAAWoC,EAAcD,GAC1G,EAAKgF,SAAS,CAACjF,KAAKqD,IAEtB,GAAkB,eAAd+C,EAA2B,CAC7B,MAAsBhD,EAAW,EAAK5E,MAAMwB,KAAKrC,EAAUC,EAAYC,EAASC,EAAWoC,EAAcD,GAA9FoD,GAAX,EAAKE,MAAL,EAAWF,SACX,EAAK4B,SAAS,CAACjF,KAAKqD,IAEtB,GAAkB,iBAAd+C,EAA6B,CAC/B,IAAM/C,EAAUO,EAAa,EAAKpF,MAAMwB,KAAKrC,EAAUC,EAAYC,EAASC,EAAWoC,EAAcD,GACrG,EAAKgF,SAAS,CAACjF,KAAKqD,IAEtB,GAAkB,aAAd+C,EAAyB,CAC3B,IAAM/C,EAAUO,EAAa,EAAKpF,MAAMwB,KAAKrC,EAAUC,EAAYC,EAASC,EAAWoC,EAAcD,GACrG,EAAKgF,SAAS,CAACjF,KAAKqD,MAhUtB,EAAK7E,MAAQ,CACXwB,KAAM,GACNqG,gBAAgB,EAChBP,YAAa,MACbQ,oBAAoB,EACpBC,oBAAoB,EACpBvE,iBAAkB,YAClBkD,WAAY,OACZC,WAAY,EACZc,UAAW,EACXG,YAAa,UAZE,E,qDAgBnB,WACE,IAAMpG,EAAOsF,GAAe,EAAO,IAAG,GACtC7G,KAAKwG,SAAS,CAAEjF,W,6BAIlB,SAAgBb,EAAKC,GAEnB,GADAX,KAAKgH,YACDtG,IAAQtB,GAAWuB,IAAQtB,EAI/B,GAAIqB,IAAQxB,GAAayB,IAAQxB,EAAjC,CAKA,IAAMyF,EAAUmD,EAA0B/H,KAAKD,MAAMwB,KAAMb,EAAKC,GAC5DA,IAAQtB,GAAcqB,IAAQtB,EAChCY,KAAKwG,SAAS,CAAEjF,KAAMvB,KAAKD,MAAMwB,KAAMqG,gBAAgB,IAEvD5H,KAAKwG,SAAS,CAAEjF,KAAMqD,EAASgD,gBAAgB,SAR/C5H,KAAKwG,SAAS,CAAEsB,oBAAoB,SAJpC9H,KAAKwG,SAAS,CAAEqB,oBAAoB,M,8BAexC,SAAiBnH,EAAKC,GAEpB,IAAsC,IAAlCX,KAAKD,MAAM8H,mBAA6B,CAC1C,GAAInH,IAAQxB,GAAayB,IAAQxB,EAC/B,OAEF,IAAMyF,EAAUoD,EAA4BhI,KAAKD,MAAMwB,KAAMb,EAAKC,GAIlE,OAHAX,KAAKwG,SAAS,CAAEjF,KAAMqD,IACtBvF,EAAasB,OACbvB,EAAUsB,GAIZ,IAAsC,IAAlCV,KAAKD,MAAM+H,mBAA6B,CAC1C,GAAIpH,IAAQtB,GAAWuB,IAAQtB,EAC7B,OAEF,IAAMuF,EAAUqD,EAA4BjI,KAAKD,MAAMwB,KAAMb,EAAKC,GAIlE,OAHAX,KAAKwG,SAAS,CAAEjF,KAAMqD,IACtBzF,EAAYwB,OACZzB,EAAYwB,GAGd,GAAKV,KAAKD,MAAM6H,iBACZjH,IAAQtB,GAAcqB,IAAQtB,GAAlC,CAGA,IAAMwF,EAAUmD,EAA0B/H,KAAKD,MAAMwB,KAAMb,EAAKC,GAChEX,KAAKwG,SAAS,CAAEjF,KAAMqD,O,2BAExB,WAEE5E,KAAKwG,SAAS,CACZoB,gBAAgB,EAChBC,oBAAoB,EACpBC,oBAAoB,M,yBAUxB,SAAYpG,EAAqBlC,EAA0B0I,GACzD,IADgE,IAAD,kBACtDrE,GACP,GAAIA,IAAMnC,EAAoBN,OAC5B,OAAkC,IAA9B5B,IAGJ,EAAK+G,aACQ,QAAT2B,EAEFvB,YAAW,WACT,EAAKwB,oBAAoBzG,KACxB,EAAImC,GAEP8C,YAAW,WACT,EAAKwB,oBAAoB3I,KACxB,EAAIqE,GAET8C,YAAW,WACT,EAAKwB,oBAAoB3I,KACxB,EAAIqE,IAfC,CAAN,UAmBJ8C,YAAW,WACT,IAAMyB,EAAO1G,EAAoBmC,GAC3BvE,EAAU8I,EAAK,GACf7I,EAAU6I,EAAK,GACjBxD,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASa,aAAc,EACxC,EAAKoG,SAAS,CAAE5B,cACf,GAAGf,GACN8C,YAAW,WACT,IAAMyB,EAAO1G,EAAoBmC,GAC3BvE,EAAU8I,EAAK,GACf7I,EAAU6I,EAAK,GACjBxD,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASa,aAAc,EACxCwE,EAAQtF,GAASC,GAASY,QAAS,EAEnC,EAAKqG,SAAS,CAAE5B,cACf,GAAKf,IAvCDA,EAAI,EAAGA,GAAKnC,EAAoBN,OAAQyC,IAAK,CAAC,IAAD,IAA7CA,GAA6C,qC,iCA4CxD,SAAoBrE,GAClB,IAD6C,IAAD,kBACnCqE,GACP8C,YAAW,WACT,IAAMyB,EAAO5I,EAAyBqE,GAChCvE,EAAU8I,EAAK,GACf7I,EAAU6I,EAAK,GACjBxD,EAAU,EAAK7E,MAAMwB,KACzBqD,EAAQtF,GAASC,GAASa,aAAc,EACxCwE,EAAQtF,GAASC,GAASY,QAAS,EACnCyE,EAAQtF,GAASC,GAASc,gBAAiB,EAC3C,EAAKmG,SAAS,CAAE5B,cACf,GAAKf,IAVDA,EAAI,EAAGA,EAAIrE,EAAyB4B,OAAQyC,IAAM,EAAlDA,K,oBA8MX,WAAU,IAAD,OACP,EAAiC7D,KAAKD,MAAxB6H,GAAd,EAAQrG,KAAR,EAAcqG,gBACd,OACE,sBAAK7G,UAAU,aAAf,UACE,qBAAKA,UAAU,UAAUsH,MAAO,CAAEC,aAAc,IAAhD,SACE,qBAAKvH,UAAU,UAAf,SACE,eAACwH,EAAA,EAAD,CAAQF,MAAO,CAACG,SAAS,IAAKC,kBAAgB,EAACC,OAAO,KAAKC,GAAG,OAAOC,QAAQ,OAA7E,UACE,cAACL,EAAA,EAAOM,MAAR,CACER,MAAO,CAACG,SAAS,IACjBM,KAAK,QAFP,4BAOA,cAACC,EAAA,EAAIC,KAAL,CAEEC,QAAS,kBAAM,EAAKrC,aAFtB,wBAMA,cAACmC,EAAA,EAAIC,KAAL,CAEEC,QAAS,kBAAM,EAAKjC,aAFtB,wBAOA,eAACkC,EAAA,EAAD,CACED,QAAS,kBAAM,EAAKlC,iBADtB,uBAIa/G,KAAKD,MAAMsH,eAExB,cAACkB,EAAA,EAAOY,OAAR,CAAeC,gBAAc,0BAC7B,eAACb,EAAA,EAAOc,SAAR,CAAiBC,GAAG,wBAApB,UACE,eAACP,EAAA,EAAD,CAAKhI,UAAU,UAAf,UACE,cAACgI,EAAA,EAAIC,KAAL,CAEEC,QAAS,WACP,EAAKvB,gBAHT,mCAUA,eAAC6B,EAAA,EAAD,CACEC,MAAM,gBACNF,GAAG,0BAFL,UAKE,cAACC,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKvB,aAAa,WADnC,qCAKA,cAAC6B,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKvB,aAAa,eADnC,yBAKA,cAAC6B,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKvB,aAAa,iBADnC,oCAKA,cAAC6B,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKvB,aAAa,aADnC,yCASF,eAAC6B,EAAA,EAAD,CACEC,MAAM,aACNF,GAAG,0BAFL,UAKE,cAACC,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKzC,SAAS,CAAEa,YAAa,SAD9C,iCAKA,cAACkC,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKzC,SAAS,CAAEa,YAAa,SAD9C,gCAKA,cAACkC,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKzC,SAAS,CAAEa,YAAa,WAD9C,gBAKA,cAACkC,EAAA,EAAYE,KAAb,CACER,QAAS,kBAAM,EAAKzC,SAAS,CAAEa,YAAa,cAD9C,yBAMF,eAACkC,EAAA,EAAD,CACEC,MAAK,qBAAgBxJ,KAAKD,MAAMwD,kBAChC+F,GAAG,0BAFL,UAKE,cAACC,EAAA,EAAYE,KAAb,CACER,QAAS,kBACP,EAAKzC,SAAS,CAAEjD,iBAAkB,eAFtC,uBAOA,cAACgG,EAAA,EAAYE,KAAb,CACER,QAAS,kBACP,EAAKzC,SAAS,CAAEjD,iBAAkB,eAFtC,uBAOA,cAACgG,EAAA,EAAYE,KAAb,CACER,QAAS,kBACP,EAAKzC,SAAS,CAAEjD,iBAAkB,YAFtC,oBAOA,cAACgG,EAAA,EAAYE,KAAb,CACER,QAAS,kBACP,EAAKzC,SAAS,CAAEjD,iBAAkB,eAFtC,6BASJ,cAACwF,EAAA,EAAD,cAKR,qBAAKhI,UAAU,OAAf,SACGf,KAAKD,MAAMwB,KAAKmI,KAAI,SAAChJ,EAAKiJ,GACzB,OACE,8BACGjJ,EAAIgJ,KAAI,SAACtB,EAAMwB,GACd,IACElJ,EASE0H,EATF1H,IACAC,EAQEyH,EARFzH,IACAV,EAOEmI,EAPFnI,SACAC,EAMEkI,EANFlI,QACAI,EAKE8H,EALF9H,OACAH,EAIEiI,EAJFjI,OACAC,EAGEgI,EAHFhI,YACAC,EAEE+H,EAFF/H,eACAO,EACEwH,EADFxH,UAEF,OACE,cAAC,EAAD,CACEA,UAAWA,EAEXD,IAAKA,EACLV,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACRC,YAAaA,EACbC,eAAgBA,EAChBC,QAAQL,IAAYC,GAAkBI,EACtCG,UAAW,kBAAM,EAAKoJ,iBACtBjC,eAAgBA,EAChBrH,YAAa,SAACG,EAAKC,GAAN,OAAc,EAAKmJ,gBAAgBpJ,EAAKC,IACrDH,aAAc,SAACE,EAAKC,GAAN,OACZ,EAAKoJ,iBAAiBrJ,EAAKC,IAE7BD,IAAKA,GAdAkJ,OAhBHD,QAsChB,sBAAKK,MAAM,UAAU3B,MAAO,CAAC4B,QAAQjK,KAAKD,MAAM0G,WAAYyD,QAASlK,KAAK0G,WAAY8B,SAAS,IAA/F,yBAAiH5F,KAAKsC,MAAMlF,KAAKD,MAAMyH,WAAvI,gB,GAxgBiCxG,aAihBnC6F,EAAiB,SAACsD,EAAaC,EAASC,GAC5C,GAAIF,EAAa,CAEf,IADA,IAAI5I,EAAO6I,EACF1J,EAAM,EAAGA,EAAMe,EAAef,IACrC,IAAK,IAAIC,EAAM,EAAGA,EAAMa,EAAeb,IAGrCY,EAAKb,GAAKC,GAAK2J,WAAY,EACvBD,IACF9I,EAAKb,GAAKC,GAAKL,QAAU,GAG3BiB,EAAKb,GAAKC,GAAK4J,aAAe,KAC9BhJ,EAAKb,GAAKC,GAAKR,QAAS,EACxBoB,EAAKb,GAAKC,GAAKP,aAAc,EAC7BmB,EAAKb,GAAKC,GAAKN,gBAAiB,EAChCkB,EAAKb,GAAKC,GAAKC,UAAY,GAG/B,OAAOW,EAGT,IADA,IAAMA,EAAO,GACJb,EAAM,EAAGA,EAAMe,EAAef,IAAO,CAE5C,IADA,IAAMkB,EAAa,GACVjB,EAAM,EAAGA,EAAMa,EAAeb,IACrCiB,EAAWnC,KAAK+K,EAAW7J,EAAKD,EAAKyJ,IAEvC5I,EAAK9B,KAAKmC,GAEZ,OAAOL,GAGHiJ,EAAa,SAAC7J,EAAKD,EAAKyJ,GAC5B,MAAO,CACLxJ,MACAD,MACAR,QAASQ,IAAQxB,GAAayB,IAAQxB,EACtCc,SAAUS,IAAQtB,GAAWuB,IAAQtB,EACrCoL,SAAUC,IACVJ,WAAW,EACXhK,QAAQ,EACRiK,aAAc,KACdpK,QAAQ,EACRC,aAAa,EACbC,gBAAgB,EAChBO,UAAW,KAIToH,EAA8B,SAACzG,EAAMb,EAAKC,GAC9C,IAAMiE,EAAUrD,EAAKsD,QAIrB,OAHAD,EAAQxF,GAASC,GAAYY,UAAW,EAExC2E,EAAQlE,GAAKC,GAAKV,UAAW,EACtB2E,GAGHqD,EAA8B,SAAC1G,EAAMb,EAAKC,GAC9C,IAAMiE,EAAUrD,EAAKsD,QAIrB,OAHAD,EAAQ1F,GAAWC,GAAWe,SAAU,EAExC0E,EAAQlE,GAAKC,GAAKT,SAAU,EACrB0E,GAGHmD,EAA4B,SAACxG,EAAMb,EAAKC,GAC5C,IAAMiE,EAAUrD,EAAKsD,QACfuD,EAAOxD,EAAQlE,GAAKC,GACpBgK,EAAO,2BACRvC,GADQ,IAEX9H,QAAS8H,EAAK9H,SAGhB,OADAsE,EAAQlE,GAAKC,GAAOgK,EACb/F,GC5mBMgG,MAVf,WACE,OACE,qBAAK7J,UAAU,MAAf,SACE,8BACE,cAAC,EAAD,SCMO8J,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.a3ba1d43.chunk.js","sourcesContent":["const nodesInShortestPath = (\r\n  parent,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN\r\n) => {\r\n  // with the help of this function and the parent 2D array, we get the path from the source to the destination\r\n  // in the order\r\n\r\n  let end_row = END_ROW;\r\n  let end_col = END_COLUMN;\r\n  let nodesInShortestPathOrder = [];\r\n  while (end_row !== START_ROW || end_col !== START_COL) {\r\n    nodesInShortestPathOrder.push([end_row, end_col]);\r\n    if (parent[end_row][end_col] == \"U\") {\r\n      end_row -= 1;\r\n    } else if (parent[end_row][end_col] == \"D\") {\r\n      end_row += 1;\r\n    } else if (parent[end_row][end_col] == \"L\") {\r\n      end_col -= 1;\r\n    } else {\r\n      end_col += 1;\r\n    }\r\n  }\r\n  nodesInShortestPathOrder.push([end_row, end_col]);\r\n  nodesInShortestPathOrder.reverse();\r\n  console.log(nodesInShortestPathOrder);\r\n  return nodesInShortestPathOrder;\r\n};\r\n\r\nexport default nodesInShortestPath;\r\n","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  // componentDidMount()\r\n\r\n  render() {\r\n    const {\r\n      isFinish,\r\n      isStart,\r\n      inPath,\r\n      inPathFirst,\r\n      inShortestPath,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,col,\r\n      direction\r\n    } = this.props;\r\n\r\n    let extraClassName = \"\";\r\n    let arrowClassName = \"\";\r\n    // console.log(this.props);\r\n    // if (isFinishNode){\r\n    //     extraClassName = isFinishNode\r\n    // }\r\n    // console.log(isFinishNode)\r\n    if (inPath) {\r\n      extraClassName = \"inPath\";\r\n    }\r\n    if (inPathFirst) {\r\n      extraClassName = \"inPathFirst\";\r\n    }\r\n    if (inShortestPath) {\r\n      extraClassName = \"inShortestPath\";\r\n      if (direction==\"U\"){\r\n        arrowClassName = \"down\";\r\n      }\r\n      if (direction==\"D\"){\r\n        arrowClassName = \"up\";\r\n      }\r\n      if (direction==\"L\"){\r\n        arrowClassName = \"right\";\r\n      }\r\n      if (direction==\"R\"){\r\n        arrowClassName = \"left\";\r\n      }\r\n    }\r\n    if (isFinish) {\r\n        extraClassName = \"isFinish\";\r\n    } else if (isStart) {\r\n        extraClassName = \"isStart\";\r\n    }\r\n    if (isWall) {\r\n      extraClassName = \"isWall\";\r\n    }\r\n    return <div onMouseDown={() => onMouseDown(row, col)}\r\n    onMouseEnter={() => onMouseEnter(row, col)}\r\n    // draggable={true?extraClassName===\"isFinish\":false}\r\n    onMouseUp={() => onMouseUp()} className={`node ${extraClassName} ${arrowClassName}` }>\r\n      <div className={` ${arrowClassName}`}></div>\r\n      {/* <div\r\n      className = {`innode ${extraClassName} ${arrowClassName}`}\r\n      ></div> */}\r\n    </div>;\r\n  }\r\n}\r\n","class Queue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  // add element to the queue\r\n  enqueue(element) {\r\n    return this.items.push(element);\r\n  }\r\n\r\n  // remove element from the queue\r\n  dequeue() {\r\n    if (this.items.length > 0) {\r\n      return this.items.shift();\r\n    }\r\n  }\r\n\r\n  // check if the queue is empty\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  // empty the queue\r\n  clear() {\r\n    this.items = [];\r\n  }\r\n}\r\nconst bfs = (START_ROW, START_COL, END_ROW, END_COLUMN, grid,NUMBER_OF_COL,NUMBER_OF_ROW) => {\r\n  // console.log(END_ROW,END_COLUMN)\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  //making visited array\r\n  let visited = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    visited.push(currentRow);\r\n  }\r\n\r\n  //creating parent array to keep track of parent so that we can backtrack the steps\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW+1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL+1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  //making queue\r\n  let queue = new Queue();\r\n  queue.enqueue([START_ROW, START_COL]);\r\n  visited[START_ROW][START_COL] = true;\r\n  while (queue.isEmpty() == false) {\r\n    const front = queue.dequeue();\r\n    let x = front[0];\r\n    let y = front[1];\r\n    visitedNodesInOrder.push([x, y]);\r\n    if (x == END_ROW && y == END_COLUMN) {\r\n      return { parent, visitedNodesInOrder };\r\n    }\r\n    if (x + 1 < NUMBER_OF_ROW) {\r\n      x += 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"U\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      x -= 1;\r\n    }\r\n    if (x > 0) {\r\n      x -= 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"D\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      x += 1;\r\n    }\r\n    if (y + 1 < NUMBER_OF_COL) {\r\n      y += 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"L\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      y -= 1;\r\n    }\r\n    if (y > 0) {\r\n      y -= 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"R\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      y += 1;\r\n    }\r\n  }\r\n  return { parent:-1, visitedNodesInOrder };\r\n  \r\n};\r\nexport default bfs;\r\n","const dfs = (\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW\r\n) => {\r\n  // console.log(END_ROW,END_COLUMN)\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  //making visited array\r\n  let visited = [];\r\n  for (let row = 0; row <= NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col <= NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    visited.push(currentRow);\r\n  }\r\n\r\n  //creating parent array to keep track of parent so that we can backtrack the steps\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW + 1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL + 1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  //making queue\r\n  //   let queue = new Queue();\r\n  let stack = [];\r\n  //   queue.enqueue([START_ROW, START_COL]);\r\n  stack.push([START_ROW, START_COL]);\r\n  //   visited[START_ROW][START_COL] = true;\r\n  while (stack.length !== 0) {\r\n    const topStack = stack.pop();\r\n    let x = topStack[0];\r\n    let y = topStack[1];\r\n    // console.log(\"vis\",x,y);\r\n    visited[x][y] = true;\r\n    visitedNodesInOrder.push([x, y]);\r\n\r\n    if (x == END_ROW && y == END_COLUMN) {\r\n      return { parent, visitedNodesInOrder };\r\n    }\r\n\r\n    if (y > 0) {\r\n      y -= 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"R\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      y += 1;\r\n    }\r\n\r\n    if (x + 1 < NUMBER_OF_ROW) {\r\n      x += 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"U\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      x -= 1;\r\n    }\r\n\r\n    if (y + 1 < NUMBER_OF_COL) {\r\n      y += 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"L\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      y -= 1;\r\n    }\r\n    if (x > 0) {\r\n      x -= 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"D\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      x += 1;\r\n    }\r\n  }\r\n  return { parent: -1, visitedNodesInOrder };\r\n};\r\nexport default dfs;\r\n","const manhattan = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n};\r\n\r\n\r\nexport default manhattan;","const chebyshev = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const dy = Math.abs(END_COL-CUR_COL);\r\n    const dx = Math.abs(END_ROW-CUR_ROW);\r\n    const distance = Math.max(dy,dx);\r\n    return distance;    \r\n};\r\n\r\n\r\nexport default chebyshev;","const octile = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const dy = Math.abs(END_COL-CUR_COL);\r\n    const dx = Math.abs(END_ROW-CUR_ROW);\r\n    const distance = 1.141 * (Math.min(dx,dy)) + Math.abs(dx-dy);\r\n    return distance;    \r\n};\r\n\r\n\r\nexport default octile;","const euclidean = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const x = Math.abs(END_ROW-CUR_ROW)*Math.abs(END_ROW-CUR_ROW)\r\n    const y = Math.abs(END_COL-CUR_COL)*Math.abs(END_COL-CUR_COL)\r\n    const d = Math.pow(x+y,0.5);\r\n    return d;\r\n\r\n};\r\n\r\n\r\nexport default euclidean;","//importing heurstic\r\nimport manhattan from \"../Heuristic/manhattan\";\r\nimport chebyshev from \"../Heuristic/chebyshev\";\r\nimport octile from \"../Heuristic/octile\";\r\nimport euclidean from \"../Heuristic/euclidean\";\r\n\r\nconst heuristic = (END_ROW, END_COL, CUR_ROW, CUR_COL, currentHeuristic) => {\r\n  // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  // console.log(\"currentHeuristic\",currentHeuristic);\r\n  if (currentHeuristic == \"Manhattan\") {\r\n    // console.log(\"in manhattan\");\r\n    const ans =  manhattan(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n    return ans;\r\n    // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  }\r\n  if (currentHeuristic == \"Chebyshev\") {\r\n    return chebyshev(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Octile\") {\r\n    return octile(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Euclidean\") {\r\n    return euclidean(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n};\r\n\r\nconst constructPath = (cameFrom, er, ec, sr, sc) => {\r\n  let path = [];\r\n  let x = cameFrom[[er, ec]];\r\n  // console.log(c)\r\n  path.push(x);\r\n  while (x[0] != sr && x[1] != sc) {\r\n    x = cameFrom[x];\r\n    path.push(x);\r\n  }\r\n  return path;\r\n};\r\n\r\nclass QueueElement {\r\n  constructor(element, priority) {\r\n    this.element = element;\r\n    this.priority = priority;\r\n  }\r\n}\r\n\r\nclass PriorityQueue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  enqueue(element, priority) {\r\n    let queueElement = new QueueElement(element, priority);\r\n    let added = false;\r\n    for (let i = 0; i < this.items.length; i++) {\r\n      if (queueElement.priority < this.items[i].priority) {\r\n        this.items.splice(i, 0, queueElement);\r\n        added = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!added) {\r\n      this.items.push(queueElement);\r\n    }\r\n  }\r\n  dequeue() {\r\n    return this.items.shift();\r\n  }\r\n\r\n  isEmpty() {\r\n    if (this.items.length === 0) return true;\r\n    return false;\r\n  }\r\n\r\n  printPQueue() {\r\n    var str = \"\";\r\n    for (var i = 0; i < this.items.length; i++)\r\n      str += this.items[i].element + \" \";\r\n    return str;\r\n  }\r\n\r\n  //   checkIfPresent(element){\r\n\r\n  //   }\r\n}\r\n\r\nconst astar = (\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW,\r\n  currentHeuristic\r\n) => {\r\n  let queue = new PriorityQueue();\r\n  let cameFrom = {};\r\n  let vis = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    vis.push(currentRow);\r\n  }\r\n\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW + 1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL + 1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  let gScore = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(100000000);\r\n    }\r\n    gScore.push(currentRow);\r\n  }\r\n  gScore[START_ROW][START_COL] = 0;\r\n\r\n  let fScore = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(100000000);\r\n    }\r\n    fScore.push(currentRow);\r\n  }\r\n  //   console.log(\"fScore\", fScore);\r\n  fScore[START_ROW][START_COL] = heuristic(\r\n    END_ROW,\r\n    END_COLUMN,\r\n    START_ROW,\r\n    START_COL,\r\n    currentHeuristic\r\n  );\r\n  //   let vis = {};\r\n  //   console.log(\"fScore\",fScore);\r\n  let visitedNodes = [];\r\n  queue.enqueue([START_ROW, START_COL], fScore[START_ROW][START_COL]);\r\n  vis[START_ROW][START_COL] = true;\r\n  const goal = [END_ROW, END_COLUMN];\r\n  //   console.log(\"f\");\r\n  while (queue.isEmpty() === false) {\r\n    // console.log(\"conetnets\",queue.printPQueue());\r\n    let minFScoreNode = queue.dequeue().element;\r\n    // console.log(minFScoreNode);\r\n    // console.log(\"compare\",minFScoreNode,goal)\r\n    if (goal[0] === minFScoreNode[0] && goal[1] === minFScoreNode[1]) {\r\n      //   console.log(\"compeed the astar\");\r\n      console.log(cameFrom);\r\n      //   return constructPath(cameFrom, END_ROW, END_COLUMN, START_ROW, START_COL);\r\n      return { parent, visitedNodes };\r\n    }\r\n    const x = minFScoreNode[0];\r\n    const y = minFScoreNode[1];\r\n    visitedNodes.push([x, y]);\r\n    let newx = x + 1;\r\n    let newy = y;\r\n    if (newx < NUMBER_OF_ROW) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        //   console.log(\"tent_score\", tent_score);\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy,currentHeuristic);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"U\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n            // console.log(\"f\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // console.log(newx, NUMBER_OF_ROW);\r\n\r\n    newx = x - 1;\r\n    newy = y;\r\n    if (newx >= 0) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"D\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    newx = x;\r\n    newy = y - 1;\r\n    if (newy >= 0) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"R\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    newx = x;\r\n    newy = y + 1;\r\n    if (newy < NUMBER_OF_COL) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy,currentHeuristic);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"L\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // for (let row = 0; row < NUMBER_OF_ROW ; row++) {\r\n    //   for (let col = 0; col < NUMBER_OF_COL ; col++) {\r\n    //     if (fScore[row][col]<currentminFScoreValue){\r\n    //         currentminFScoreValue=  fScore[row][col];\r\n    //         minFScoreNode = [row,col];\r\n    //     }\r\n    //   }\r\n    // }\r\n  }\r\n  return { parent: -1, visitedNodes };\r\n};\r\n\r\n// const astar = (\r\n//   START_ROW,\r\n//   START_COL,\r\n//   END_ROW,\r\n//   END_COLUMN,\r\n//   grid,\r\n//   NUMBER_OF_COL,\r\n//   NUMBER_OF_ROW\r\n// ) => {};\r\n\r\nexport default astar;\r\n","function randomMaze(grid,START_ROW,START_COL , END_ROW, END_COL,NUMBER_OF_ROW,NUMBER_OF_COL) {\r\n//   if (!startNode || !finishNode || startNode === finishNode) {\r\n//     return false;\r\n//   }\r\n  let newGrid = grid.slice();\r\n  let walls = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      if (\r\n        (row === START_ROW && col === START_COL) ||\r\n        (row === END_ROW && col === END_COL)\r\n      )\r\n        continue;\r\n      if (Math.random() < 0.33) {\r\n        walls.push([row, col]);\r\n        newGrid[row][col].isWall = true;\r\n      }\r\n    }\r\n  }\r\n  walls.sort(() => Math.random() - 0.5);\r\n  return {walls, newGrid};\r\n}\r\nexport default randomMaze;\r\n","function randomNumber(min, max) { \r\n    return Math.floor(Math.random() * (max - min) + min);\r\n} \r\n\r\nconst verticalMaze = (grid,START_ROW,START_COL , END_ROW, END_COL,NUMBER_OF_ROW,NUMBER_OF_COL) => {\r\n    let newGrid = grid.slice();\r\n    for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n        if (row==START_ROW && (0==START_COL || START_COL==NUMBER_OF_COL-1)) continue;\r\n        if (row==END_ROW && (0==END_COL || END_COL==NUMBER_OF_COL-1)) continue;\r\n        newGrid[row][0].isWall = true;\r\n        newGrid[row][NUMBER_OF_COL-1].isWall = true;\r\n    }\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n        if (col==START_COL && (0==START_ROW || START_ROW==NUMBER_OF_ROW-1)) continue;\r\n        if (col==END_COL && (0==END_ROW || END_ROW ==NUMBER_OF_ROW-1)) continue;\r\n        newGrid[0][col].isWall=true;\r\n        newGrid[NUMBER_OF_ROW-1][col].isWall=true;\r\n    }\r\n    for (let row=0;row<NUMBER_OF_ROW;row++){\r\n        \r\n        if (row%2===1) continue;\r\n        let random = randomNumber(0,NUMBER_OF_COL);\r\n        if (row===START_ROW || row===END_ROW){\r\n            if (START_ROW===END_ROW){\r\n                for (let col=0;col<NUMBER_OF_COL;col++){\r\n                    if (col!==START_COL && col!==END_COL){\r\n                        // console.log(newGrid);\r\n                        newGrid[row][col].isWall = true;\r\n                        // console.log(newGrid[row][col].isWall )\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            while(random!==START_COL && random!==END_COL){\r\n                random = randomNumber(0,NUMBER_OF_COL);\r\n            }\r\n            // if (row===END_ROW){\r\n            //     if (random===END_COL){\r\n            //         random = randomNumber(0,NUMBER_OF_COL);\r\n            //     }\r\n            // }\r\n            // if (row===START_ROW){\r\n            //     if (random===START_COL){\r\n            //         random = randomNumber(0,NUMBER_OF_COL);\r\n            //     }\r\n            // }\r\n        }\r\n        \r\n        for (let col=0;col<NUMBER_OF_COL;col++){\r\n            if (col!==random){\r\n                // console.log(newGrid);\r\n                newGrid[row][col].isWall = true;\r\n                // console.log(newGrid[row][col].isWall )\r\n            }\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nexport default verticalMaze;","// recursiveDivision\r\n\r\nlet walls;\r\nfunction recursiveDivision(\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL,\r\n  NUMBER_OF_ROW,\r\n  NUMBER_OF_COL\r\n) {\r\n  let vertical = [];\r\n  let horizontal = [];\r\n\r\n  for (let row = 1; row < grid.length; row++) horizontal.push(row);\r\n  for (let col = 1; col < grid[0].length; col++) vertical.push(col);\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    if (row==START_ROW && (0==START_COL || START_COL==NUMBER_OF_COL-1)) continue;\r\n    if (row==END_ROW && (0==END_COL || END_COL==NUMBER_OF_COL-1)) continue;\r\n    grid[row][0].isWall = true;\r\n    grid[row][NUMBER_OF_COL-1].isWall = true;\r\n}\r\nfor (let col = 0; col < NUMBER_OF_COL; col++) {\r\n    if (col==START_COL && (0==START_ROW || START_ROW==NUMBER_OF_ROW-1)) continue;\r\n    if (col==END_COL && (0==END_ROW || END_ROW ==NUMBER_OF_ROW-1)) continue;\r\n    grid[0][col].isWall=true;\r\n    grid[NUMBER_OF_ROW-1][col].isWall=true;\r\n}\r\nNUMBER_OF_COL-=1;\r\nNUMBER_OF_ROW-=1;\r\n  walls = [];\r\n  rec(vertical, horizontal, grid, START_ROW, START_COL, END_ROW, END_COL);\r\n  console.log(\"grid\",grid);\r\n  return grid;\r\n}\r\n\r\nconst rec = (\r\n  vertical,\r\n  horizontal,\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL\r\n) => {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let direction = 0;\r\n  let number = 0;\r\n  if (vertical.length > horizontal.length) {\r\n    direction = 0;\r\n    number = generateOddRandomNumber(vertical);\r\n  } else {\r\n    direction = 1;\r\n    number = generateOddRandomNumber(horizontal);\r\n  }\r\n  if (direction === 0) {\r\n    addWall(direction, number,grid, vertical, horizontal,  START_ROW, START_COL, END_ROW, END_COL);\r\n    rec(\r\n      vertical.slice(0, vertical.indexOf(number)),\r\n      horizontal,\r\n      grid,\r\n      START_ROW, START_COL, END_ROW, END_COL\r\n    );\r\n    rec(\r\n      vertical.slice(vertical.indexOf(number) + 1),\r\n      horizontal,\r\n      grid,\r\n      START_ROW, START_COL, END_ROW, END_COL\r\n    );\r\n  }\r\n  else{\r\n    addWall(direction, number,grid, vertical, horizontal, START_ROW, START_COL, END_ROW, END_COL);\r\n    rec(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(number)),\r\n      grid,\r\n      START_ROW, START_COL, END_ROW, END_COL\r\n    );\r\n    rec(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(number) + 1),\r\n      grid,\r\n      START_ROW, START_COL, END_ROW, END_COL\r\n    );\r\n  }\r\n};\r\n\r\nfunction addWall(dir, num,grid, vertical, horizontal, START_ROW, START_COL, END_ROW, END_COL) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (temp === START_ROW && num === START_COL) ||\r\n        (temp === END_ROW && num === END_COL)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (temp === START_ROW && num === START_COL) ||\r\n        (temp === END_ROW && num === END_COL)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n    if (wall==undefined) continue;\r\n    // console.log(\"wall\",wall);\r\n    // console.log(\"wall[0]\",wall[0]);\r\n    \r\n    grid[wall[0]][wall[1]].isWall = true;\r\n  }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}\r\nfunction generateOddRandomNumber(array) {\r\n  let max = array.length - 1;\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return array[randomNum];\r\n}\r\n\r\nexport default recursiveDivision;\r\n","import React, { Component } from \"react\";\r\n\r\nimport nodesInShortestPath from \"../helper functions/nodesInShortestPath\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\r\n\r\nimport Popup from \"reactjs-popup\";\r\nimport \"reactjs-popup/dist/index.css\";\r\n\r\nimport Node from \"./Node/Node\";\r\n\r\nimport \"./PathFinding.css\";\r\n\r\nimport bfs from \"../algorithms/bfs\";\r\nimport dfs from \"../algorithms/dfs\";\r\nimport astar from \"../algorithms/astar\";\r\n\r\nimport randomMaze from \"../Maze/randomMazeGen\";\r\nimport verticalMaze from \"../Maze/verticalMaze\";\r\nimport recursiveDivision from \"../Maze/recursiveDivision\"\r\n\r\n//constants\r\nlet START_ROW = 10;\r\nlet START_COL = 10;\r\nlet END_ROW = 10;\r\nlet END_COLUMN = 31;\r\n\r\nconst NUMBER_OF_ROW = 25;\r\nconst NUMBER_OF_COL = 60;\r\n\r\nexport default class PathFinding extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      currentAlgo: \"BFS\",\r\n      mousePressedTarget: false,\r\n      mousePressedSource: false,\r\n      currentHeuristic: \"Manhattan\",\r\n      msgDisplay: \"none\",\r\n      msgOpacity: 0,\r\n      timeTaken: 0,\r\n      currentMaze: \"recDiv\"\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(false, [],false);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  //mouse events\r\n  handleMouseDown(row, col) {\r\n    this.clearPath();\r\n    if (row === END_ROW && col === END_COLUMN) {\r\n      this.setState({ mousePressedTarget: true });\r\n      return;\r\n    }\r\n    if (row === START_ROW && col === START_COL) {\r\n      this.setState({ mousePressedSource: true });\r\n      return;\r\n    }\r\n\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    if (col === END_COLUMN && row === END_ROW) {\r\n      this.setState({ grid: this.state.grid, mouseIsPressed: true });\r\n    } else {\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n  handleMouseEnter(row, col) {\r\n    // console.log(\"mouse enter\");\r\n    if (this.state.mousePressedTarget === true) {\r\n      if (row === START_ROW && col === START_COL) {\r\n        return;\r\n      }\r\n      const newGrid = getNewGridWithTargetChanged(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      END_COLUMN = col;\r\n      END_ROW = row;\r\n      return;\r\n    }\r\n    // mousePressedSource\r\n    if (this.state.mousePressedSource === true) {\r\n      if (row === END_ROW && col === END_COLUMN) {\r\n        return;\r\n      }\r\n      const newGrid = getNewGridWithSourceChanged(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      START_COL = col;\r\n      START_ROW = row;\r\n      return;\r\n    }\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (col === END_COLUMN && row === END_ROW) {\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n  handleMouseUp() {\r\n    // console.log(\"mouse up\");\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n      mousePressedTarget: false,\r\n      mousePressedSource: false,\r\n    });\r\n  }\r\n  displayMsg = () => {\r\n    // console.log()\r\n    this.setState({msgDisplay:\"block\", msgOpacity:1});\r\n    setTimeout(() => {\r\n      this.setState({msgDisplay:\"none\", msgOpacity:0});\r\n    },5000)\r\n  }\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder, algo) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        if (nodesInShortestPathOrder === -1) {\r\n          return;\r\n        }\r\n        this.displayMsg();\r\n        if (algo === \"DFS\") {\r\n          \r\n          setTimeout(() => {\r\n            this.animateShortestPath(visitedNodesInOrder);\r\n          }, 5 * i);\r\n        } else {\r\n          setTimeout(() => {\r\n            this.animateShortestPath(nodesInShortestPathOrder);\r\n          }, 5 * i);\r\n        }\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 5 * i);\r\n        return;\r\n      }\r\n      //ss\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = true;\r\n        this.setState({ newGrid });\r\n      }, 10*i);\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = false;\r\n        newGrid[end_row][end_col].inPath = true;\r\n\r\n        this.setState({ newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //this function makes the inshortestpath properity of the row and column true and uses setTimeout\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = false;\r\n        newGrid[end_row][end_col].inPath = false;\r\n        newGrid[end_row][end_col].inShortestPath = true;\r\n        this.setState({ newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //function for resetting the grid\r\n  resetGrid = () => {\r\n    const grid = getInitialGrid(false, [],false);\r\n    this.setState({ grid });\r\n  };\r\n\r\n  drawArrows = (parent) => {\r\n    \r\n    let end_row = END_ROW;\r\n    let end_col = END_COLUMN;\r\n    while (end_row !== START_ROW || end_col !== START_COL) {\r\n      // let newGrid = this.state.grid;\r\n      // newGrid[end_row][end_col].direction = parent[end_row][end_col];\r\n      // this.setState({ newGrid });\r\n\r\n      if (parent[end_row][end_col] == \"U\") {\r\n        end_row -= 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"U\";\r\n        this.setState({ newGrid });\r\n      } else if (parent[end_row][end_col] == \"D\") {\r\n        end_row += 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"D\";\r\n        this.setState({ newGrid });\r\n      } else if (parent[end_row][end_col] == \"L\") {\r\n        end_col -= 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"L\";\r\n        this.setState({ newGrid });\r\n      } else {\r\n        end_col += 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"R\";\r\n        this.setState({ newGrid });\r\n      }\r\n    }\r\n  };\r\n\r\n  parent = -1;\r\n  visualizeAlgo = () => {\r\n    this.clearPath();\r\n    let tempGrid = this.state.grid;\r\n    tempGrid[START_ROW][START_COL].isWall=false;\r\n    tempGrid[END_ROW][END_COLUMN].isWall=false;\r\n    const prevTime = performance.now();\r\n    if (this.state.currentAlgo === \"ASTAR\") {\r\n      // console.log(\"this.state.currentHeuristic\", this.state.currentHeuristic);\r\n      alert(\"ASTAR is wrong\")\r\n      const currentHeuristic = this.state.currentHeuristic;\r\n      const { parent, visitedNodes } = astar(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW,\r\n        currentHeuristic\r\n      );\r\n      const finalTime = performance.now();\r\n      this.setState({timeTaken:(finalTime-prevTime)});\r\n      console.log(parent);\r\n      let nodesInShortestPathOrder = [];\r\n      console.log(parent);\r\n      if (parent !== -1 && parent != undefined) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodes, nodesInShortestPathOrder, \"BFS\");\r\n    }\r\n    if (this.state.currentAlgo == \"BFS\") {\r\n      \r\n      \r\n      let { parent, visitedNodesInOrder } = bfs(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW\r\n      );\r\n      \r\n      const finalTime = performance.now();\r\n      this.setState({timeTaken:(finalTime-prevTime)});\r\n      let nodesInShortestPathOrder = -1;\r\n      if (parent !== -1) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder, \"BFS\");\r\n    } else if (this.state.currentAlgo === \"DFS\") {\r\n      console.log(\"in dfs\");\r\n      let { parent, visitedNodesInOrder } = dfs(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW\r\n      );\r\n      const finalTime = performance.now();\r\n      this.setState({timeTaken:(finalTime-prevTime)});\r\n      // console.log(\"visitedNodesInOrder\",visitedNodesInOrder);\r\n      let nodesInShortestPathOrder = -1;\r\n      if (parent !== -1) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodesInOrder, visitedNodesInOrder, \"DFS\");\r\n    }\r\n  };\r\n\r\n  clearPath = () => {\r\n    this.setState({ grid: getInitialGrid(true, this.state.grid,false) });\r\n  };\r\n\r\n  generateMaze = (currentMaze) => {\r\n    let tempGrid = this.state.grid;\r\n    tempGrid[START_ROW][START_COL].isStart = false;\r\n    START_ROW = 1;\r\n    START_COL = 1;\r\n    tempGrid[START_ROW][START_COL].isStart = true;\r\n    tempGrid[END_ROW][END_COLUMN].isFinish=false;\r\n    END_COLUMN = NUMBER_OF_COL-2;\r\n    END_ROW = NUMBER_OF_ROW-2;\r\n    tempGrid[END_ROW][END_COLUMN].isFinish=true;\r\n    this.setState({grid:tempGrid});\r\n    this.setState({ grid: getInitialGrid(true, this.state.grid,true) });\r\n\r\n\r\n    if (currentMaze===\"recDiv\"){\r\n      const newGrid = recursiveDivision(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (currentMaze===\"randomMaze\"){\r\n      let {walls,newGrid} = randomMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (currentMaze===\"verticalMaze\"){\r\n      const newGrid = verticalMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (currentMaze===\"horzMaze\"){\r\n      const newGrid = verticalMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //for random Maze\r\n    // this.setState({ grid: getInitialGrid(true, this.state.grid,true) });\r\n    // let {walls,newGrid} = randomMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n    // console.log(\"returned grid\",newGrid)\r\n    // this.setState({grid:newGrid});\r\n    // console.log(this.state.grid);\r\n  };\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    return (\r\n      <div className=\"containerr\">\r\n        <div className=\"headerr\" style={{ marginBottom: 10 }}>\r\n          <div className=\"navbarr\">\r\n            <Navbar style={{fontSize:18}} collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\">\r\n              <Navbar.Brand\r\n                style={{fontSize:25}}\r\n                href=\"#home\"\r\n                // style={{ marginLeft: 4, fontSize: 35 }}\r\n              >\r\n                The PathFinder\r\n              </Navbar.Brand>\r\n              <Nav.Link\r\n                // style={{ marginRight: 10, fontSize: 25 }}\r\n                onClick={() => this.resetGrid()}\r\n              >\r\n                Reset Grid\r\n              </Nav.Link>\r\n              <Nav.Link\r\n                // style={{ marginRight: 10, fontSize: 25 }}\r\n                onClick={() => this.clearPath()}\r\n              >\r\n                Clear Path\r\n              </Nav.Link>\r\n\r\n              <Button\r\n                onClick={() => this.visualizeAlgo()}\r\n                // style={{ marginRight: 20, marginLeft: 20, fontSize: 20 }}\r\n              >\r\n                Visualize {this.state.currentAlgo}\r\n              </Button>\r\n              <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\r\n              <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n                <Nav className=\"mr-auto\">\r\n                  <Nav.Link\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                    onClick={() => {\r\n                      this.generateMaze();\r\n                    }}\r\n                  >\r\n                    Random Maze Generator\r\n                  </Nav.Link>\r\n                  \r\n\r\n                  <NavDropdown\r\n                    title=\"Generate Maze\"\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"recDiv\")}\r\n                    >\r\n                      Recursive Division Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"randomMaze\")}\r\n                    >\r\n                      Random Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"verticalMaze\")}\r\n                    >\r\n                      Vertical Division Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"horzMaze\")}\r\n                    >\r\n                      Horizontal Division Maze\r\n                    </NavDropdown.Item>\r\n                    \r\n                  </NavDropdown>\r\n\r\n\r\n                  <NavDropdown\r\n                    title=\"Algorithms\"\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"BFS\" })}\r\n                    >\r\n                      Breath first search\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"DFS\" })}\r\n                    >\r\n                      Depth first search\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"ASTAR\" })}\r\n                    >\r\n                      A*\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"DIJKSTRA\" })}\r\n                    >\r\n                      Dijkstra\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n                  <NavDropdown\r\n                    title={`Heuristic: ${this.state.currentHeuristic}`}\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Manhattan\" })\r\n                      }\r\n                    >\r\n                      Manhattan\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Euclidean\" })\r\n                      }\r\n                    >\r\n                      Euclidean\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Octile\" })\r\n                      }\r\n                    >\r\n                      Octile\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Chebyshev\" })\r\n                      }\r\n                    >\r\n                      Chebyshev\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n                </Nav>\r\n                <Nav></Nav>\r\n              </Navbar.Collapse>\r\n            </Navbar>\r\n          </div>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {this.state.grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isFinish,\r\n                    isStart,\r\n                    isWall,\r\n                    inPath,\r\n                    inPathFirst,\r\n                    inShortestPath,\r\n                    direction,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      direction={direction}\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      inPath={inPath}\r\n                      inPathFirst={inPathFirst}\r\n                      inShortestPath={inShortestPath}\r\n                      isWall={isFinish || isStart ? false : isWall}\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <div class=\"message\" style={{display:this.state.msgDisplay, opacity: this.msgOpacity, fontSize:20}}>Time Taken: {Math.floor(this.state.timeTaken)} ms</div>\r\n        {/* <div className=\"popupContainer\">\r\n            hey i am a popup\r\n          </div> */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (isClearPath, gridArg, resetWall) => {\r\n  if (isClearPath) {\r\n    let grid = gridArg;\r\n    for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n      for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n        // currentRow.push(createNode(col, row, isClearPath));\r\n\r\n        grid[row][col].isVisited = false;\r\n        if (resetWall){\r\n          grid[row][col].isWall =  false;\r\n        }\r\n        \r\n        grid[row][col].previousNode = null;\r\n        grid[row][col].inPath = false;\r\n        grid[row][col].inPathFirst = false;\r\n        grid[row][col].inShortestPath = false;\r\n        grid[row][col].direction = \"\";\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n  const grid = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(createNode(col, row, isClearPath));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row, isClearPath) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_ROW && col === START_COL,\r\n    isFinish: row === END_ROW && col === END_COLUMN,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    inPath: false,\r\n    inPathFirst: false,\r\n    inShortestPath: false,\r\n    direction: \"\",\r\n  };\r\n};\r\n\r\nconst getNewGridWithTargetChanged = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  newGrid[END_ROW][END_COLUMN].isFinish = false;\r\n  // newGrid[row][col].isWall = false;\r\n  newGrid[row][col].isFinish = true;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithSourceChanged = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  newGrid[START_ROW][START_COL].isStart = false;\r\n  // newGrid[row][col].isWall = false;\r\n  newGrid[row][col].isStart = true;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import './App.css';\nimport PathFinding from \"./PathFindingVisual/PathFinding\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div>\n        <PathFinding></PathFinding>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}