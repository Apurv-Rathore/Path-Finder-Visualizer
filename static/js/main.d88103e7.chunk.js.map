{"version":3,"sources":["helper functions/nodesInShortestPath.jsx","PathFindingVisual/Node/Node.jsx","algorithms/bfs.jsx","algorithms/dfs.jsx","Heuristic/manhattan.jsx","Heuristic/chebyshev.jsx","Heuristic/octile.jsx","Heuristic/euclidean.jsx","algorithms/astar.jsx","algorithms/astar2.jsx","Maze/randomMazeGen.jsx","Maze/verticalMaze.jsx","Maze/recursiveDivision.jsx","PathFindingVisual/PathFinding.jsx","App.js","reportWebVitals.js","index.js"],"names":["nodesInShortestPath","parent","START_ROW","START_COL","END_ROW","END_COLUMN","end_row","end_col","nodesInShortestPathOrder","push","reverse","console","log","Node","props","state","this","isFinish","isStart","inPath","inPathFirst","inShortestPath","isWall","onMouseDown","onMouseEnter","onMouseUp","row","col","direction","extraClassName","arrowClassName","shortestPathAstar","className","Component","Queue","items","element","length","shift","bfs","grid","NUMBER_OF_COL","NUMBER_OF_ROW","visitedNodesInOrder","visited","currentRow","queue","enqueue","isEmpty","front","dequeue","x","y","dfs","stack","topStack","pop","manhattan","END_COL","CUR_ROW","CUR_COL","Math","abs","chebyshev","dy","dx","max","octile","min","euclidean","pow","heuristic","currentHeuristic","QueueElement","priority","PriorityQueue","queueElement","added","i","splice","str","astar","cameFrom","vis","gScore","fScore","visitedNodes","goal","minFScoreNode","newx","newy","tent_score","position","g","h","f","other","return_path","current_node","path","result","index","roww","j","current","undefined","pr","pc","cr","cc","astar2","start_node","end_node","yet_to_visit_list","visited_list","outer_iterations","move","current_index","item","max_iterations","alert","newyettovisitlist","indexxx","isEqual","childrens","indexx","new_position","nodeposition","new_node","child","includes","flag","randomMaze","newGrid","slice","walls","random","sort","randomNumber","floor","verticalMaze","rec","vertical","horizontal","number","generateOddRandomNumber","addWall","indexOf","dir","num","isStartFinish","tempWalls","temp","randomNum","generateRandomNumber","wall","array","recursiveDivision","PathFinding","displayMsg","setState","msgDisplay","msgOpacity","setTimeout","resetGrid","getInitialGrid","drawArrowsASTAR","drawArrows","visualizeAlgo","clearPath","tempGrid","prevTime","performance","now","currentAlgo","animateAlgo","finalTime","timeTaken","generateMaze","currentMaze","mouseIsPressed","mousePressedTarget","mousePressedSource","getNewGridWithWallToggled","getNewGridWithTargetChanged","getNewGridWithSourceChanged","algo","animateShortestPath","node","style","marginBottom","Navbar","fontSize","collapseOnSelect","expand","bg","variant","Brand","href","Nav","Link","onClick","Toggle","aria-controls","Collapse","id","NavDropdown","title","Item","Button","map","rowIdx","nodeIdx","handleMouseUp","handleMouseDown","handleMouseEnter","class","display","opacity","isClearPath","gridArg","resetWall","isVisited","previousNode","createNode","distance","Infinity","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d88103e7.chunk.js","sourcesContent":["const nodesInShortestPath = (\r\n  parent,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN\r\n) => {\r\n  // with the help of this function and the parent 2D array, we get the path from the source to the destination\r\n  // in the order\r\n\r\n  let end_row = END_ROW;\r\n  let end_col = END_COLUMN;\r\n  let nodesInShortestPathOrder = [];\r\n  while (end_row !== START_ROW || end_col !== START_COL) {\r\n    nodesInShortestPathOrder.push([end_row, end_col]);\r\n    if (parent[end_row][end_col] == \"U\") {\r\n      end_row -= 1;\r\n    } else if (parent[end_row][end_col] == \"D\") {\r\n      end_row += 1;\r\n    } else if (parent[end_row][end_col] == \"L\") {\r\n      end_col -= 1;\r\n    } else {\r\n      end_col += 1;\r\n    }\r\n  }\r\n  nodesInShortestPathOrder.push([end_row, end_col]);\r\n  nodesInShortestPathOrder.reverse();\r\n  console.log(nodesInShortestPathOrder);\r\n  return nodesInShortestPathOrder;\r\n};\r\n\r\nexport default nodesInShortestPath;\r\n","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  // componentDidMount()\r\n\r\n  render() {\r\n    const {\r\n      isFinish,\r\n      isStart,\r\n      inPath,\r\n      inPathFirst,\r\n      inShortestPath,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,col,\r\n      direction,\r\n      shortestPathAstar\r\n    } = this.props;\r\n\r\n    let extraClassName = \"\";\r\n    let arrowClassName = \"\";\r\n    // console.log(this.props);\r\n    // if (isFinishNode){\r\n    //     extraClassName = isFinishNode\r\n    // }\r\n    // console.log(isFinishNode)\r\n    if (inPath) {\r\n      extraClassName = \"inPath\";\r\n    }\r\n    if (inPathFirst) {\r\n      extraClassName = \"inPathFirst\";\r\n    }\r\n    if (inShortestPath) {\r\n      extraClassName = \"inShortestPath\";\r\n      if (direction==\"U\"){\r\n        arrowClassName = \"down\";\r\n      }\r\n      if (direction==\"D\"){\r\n        arrowClassName = \"up\";\r\n      }\r\n      if (direction==\"L\"){\r\n        arrowClassName = \"right\";\r\n      }\r\n      if (direction==\"R\"){\r\n        arrowClassName = \"left\";\r\n      }\r\n    }\r\n    if (shortestPathAstar){\r\n      extraClassName =  \"shortestPathAstar\";\r\n    }\r\n    if (isFinish) {\r\n        extraClassName = \"isFinish\";\r\n    } else if (isStart) {\r\n        extraClassName = \"isStart\";\r\n    }\r\n    if (isWall) {\r\n      extraClassName = \"isWall\";\r\n    }\r\n    return <div onMouseDown={() => onMouseDown(row, col)}\r\n    onMouseEnter={() => onMouseEnter(row, col)}\r\n    // draggable={true?extraClassName===\"isFinish\":false}\r\n    onMouseUp={() => onMouseUp()} className={`node ${extraClassName} ${arrowClassName}` }>\r\n      <div className={` ${arrowClassName}`}></div>\r\n      {/* <div\r\n      className = {`innode ${extraClassName} ${arrowClassName}`}\r\n      ></div> */}\r\n    </div>;\r\n  }\r\n}\r\n","class Queue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  // add element to the queue\r\n  enqueue(element) {\r\n    return this.items.push(element);\r\n  }\r\n\r\n  // remove element from the queue\r\n  dequeue() {\r\n    if (this.items.length > 0) {\r\n      return this.items.shift();\r\n    }\r\n  }\r\n\r\n  // check if the queue is empty\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  // empty the queue\r\n  clear() {\r\n    this.items = [];\r\n  }\r\n}\r\nconst bfs = (START_ROW, START_COL, END_ROW, END_COLUMN, grid,NUMBER_OF_COL,NUMBER_OF_ROW) => {\r\n  // console.log(END_ROW,END_COLUMN)\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  //making visited array\r\n  let visited = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    visited.push(currentRow);\r\n  }\r\n\r\n  //creating parent array to keep track of parent so that we can backtrack the steps\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW+1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL+1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  //making queue\r\n  let queue = new Queue();\r\n  queue.enqueue([START_ROW, START_COL]);\r\n  visited[START_ROW][START_COL] = true;\r\n  while (queue.isEmpty() == false) {\r\n    const front = queue.dequeue();\r\n    let x = front[0];\r\n    let y = front[1];\r\n    visitedNodesInOrder.push([x, y]);\r\n    if (x == END_ROW && y == END_COLUMN) {\r\n      return { parent, visitedNodesInOrder };\r\n    }\r\n    if (x + 1 < NUMBER_OF_ROW) {\r\n      x += 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"U\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      x -= 1;\r\n    }\r\n    if (x > 0) {\r\n      x -= 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"D\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      x += 1;\r\n    }\r\n    if (y + 1 < NUMBER_OF_COL) {\r\n      y += 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"L\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      y -= 1;\r\n    }\r\n    if (y > 0) {\r\n      y -= 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"R\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      y += 1;\r\n    }\r\n  }\r\n  return { parent:-1, visitedNodesInOrder };\r\n  \r\n};\r\nexport default bfs;\r\n","const dfs = (\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW\r\n) => {\r\n  // console.log(END_ROW,END_COLUMN)\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  //making visited array\r\n  let visited = [];\r\n  for (let row = 0; row <= NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col <= NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    visited.push(currentRow);\r\n  }\r\n\r\n  //creating parent array to keep track of parent so that we can backtrack the steps\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW + 1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL + 1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  //making queue\r\n  //   let queue = new Queue();\r\n  let stack = [];\r\n  //   queue.enqueue([START_ROW, START_COL]);\r\n  stack.push([START_ROW, START_COL]);\r\n  //   visited[START_ROW][START_COL] = true;\r\n  while (stack.length !== 0) {\r\n    const topStack = stack.pop();\r\n    let x = topStack[0];\r\n    let y = topStack[1];\r\n    // console.log(\"vis\",x,y);\r\n    visited[x][y] = true;\r\n    visitedNodesInOrder.push([x, y]);\r\n\r\n    if (x == END_ROW && y == END_COLUMN) {\r\n      return { parent, visitedNodesInOrder };\r\n    }\r\n\r\n    if (y > 0) {\r\n      y -= 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"R\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      y += 1;\r\n    }\r\n\r\n    if (x + 1 < NUMBER_OF_ROW) {\r\n      x += 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"U\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      x -= 1;\r\n    }\r\n\r\n    if (y + 1 < NUMBER_OF_COL) {\r\n      y += 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"L\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      y -= 1;\r\n    }\r\n    if (x > 0) {\r\n      x -= 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"D\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      x += 1;\r\n    }\r\n  }\r\n  return { parent: -1, visitedNodesInOrder };\r\n};\r\nexport default dfs;\r\n","const manhattan = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n};\r\n\r\n\r\nexport default manhattan;","const chebyshev = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const dy = Math.abs(END_COL-CUR_COL);\r\n    const dx = Math.abs(END_ROW-CUR_ROW);\r\n    const distance = Math.max(dy,dx);\r\n    return distance;    \r\n};\r\n\r\n\r\nexport default chebyshev;","const octile = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const dy = Math.abs(END_COL-CUR_COL);\r\n    const dx = Math.abs(END_ROW-CUR_ROW);\r\n    const distance = 1.141 * (Math.min(dx,dy)) + Math.abs(dx-dy);\r\n    return distance;    \r\n};\r\n\r\n\r\nexport default octile;","const euclidean = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const x = Math.abs(END_ROW-CUR_ROW)*Math.abs(END_ROW-CUR_ROW)\r\n    const y = Math.abs(END_COL-CUR_COL)*Math.abs(END_COL-CUR_COL)\r\n    const d = Math.pow(x+y,0.5);\r\n    return d;\r\n\r\n};\r\n\r\n\r\nexport default euclidean;","//importing heurstic\r\nimport manhattan from \"../Heuristic/manhattan\";\r\nimport chebyshev from \"../Heuristic/chebyshev\";\r\nimport octile from \"../Heuristic/octile\";\r\nimport euclidean from \"../Heuristic/euclidean\";\r\n\r\nconst heuristic = (END_ROW, END_COL, CUR_ROW, CUR_COL, currentHeuristic) => {\r\n  // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  // console.log(\"currentHeuristic\",currentHeuristic);\r\n  if (currentHeuristic == \"Manhattan\") {\r\n    // console.log(\"in manhattan\");\r\n    const ans =  manhattan(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n    return ans;\r\n    // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  }\r\n  if (currentHeuristic == \"Chebyshev\") {\r\n    return chebyshev(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Octile\") {\r\n    return octile(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Euclidean\") {\r\n    return euclidean(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n};\r\n\r\nconst constructPath = (cameFrom, er, ec, sr, sc) => {\r\n  let path = [];\r\n  let x = cameFrom[[er, ec]];\r\n  // console.log(c)\r\n  path.push(x);\r\n  while (x[0] != sr && x[1] != sc) {\r\n    x = cameFrom[x];\r\n    path.push(x);\r\n  }\r\n  return path;\r\n};\r\n\r\nclass QueueElement {\r\n  constructor(element, priority) {\r\n    this.element = element;\r\n    this.priority = priority;\r\n  }\r\n}\r\n\r\nclass PriorityQueue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  enqueue(element, priority) {\r\n    let queueElement = new QueueElement(element, priority);\r\n    let added = false;\r\n    for (let i = 0; i < this.items.length; i++) {\r\n      if (queueElement.priority < this.items[i].priority) {\r\n        this.items.splice(i, 0, queueElement);\r\n        added = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!added) {\r\n      this.items.push(queueElement);\r\n    }\r\n  }\r\n  dequeue() {\r\n    \r\n    return this.items.shift();\r\n  }\r\n\r\n  isEmpty() {\r\n    if (this.items.length === 0) return true;\r\n    return false;\r\n  }\r\n\r\n  printPQueue() {\r\n    var str = \"\";\r\n    for (var i = 0; i < this.items.length; i++)\r\n      str += this.items[i].element + \" \";\r\n    return str;\r\n  }\r\n\r\n  //   checkIfPresent(element){\r\n\r\n  //   }\r\n}\r\n\r\nconst astar = (\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW,\r\n  currentHeuristic\r\n) => {\r\n  let queue = new PriorityQueue();\r\n  let cameFrom = {};\r\n  let vis = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    vis.push(currentRow);\r\n  }\r\n\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW + 1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL + 1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  let gScore = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(100000000);\r\n    }\r\n    gScore.push(currentRow);\r\n  }\r\n  gScore[START_ROW][START_COL] = 0;\r\n\r\n  let fScore = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(100000000);\r\n    }\r\n    fScore.push(currentRow);\r\n  }\r\n  //   console.log(\"fScore\", fScore);\r\n  fScore[START_ROW][START_COL] = heuristic(\r\n    END_ROW,\r\n    END_COLUMN,\r\n    START_ROW,\r\n    START_COL,\r\n    currentHeuristic\r\n  );\r\n  //   let vis = {};\r\n  //   console.log(\"fScore\",fScore);\r\n  let visitedNodes = [];\r\n  queue.enqueue([START_ROW, START_COL], fScore[START_ROW][START_COL]);\r\n  vis[START_ROW][START_COL] = true;\r\n  const goal = [END_ROW, END_COLUMN];\r\n  //   console.log(\"f\");\r\n  while (queue.isEmpty() === false) {\r\n    // console.log(\"conetnets\",queue.printPQueue());\r\n    let minFScoreNode = queue.dequeue().element;\r\n    // console.log(minFScoreNode);\r\n    // console.log(\"compare\",minFScoreNode,goal)\r\n    if (goal[0] === minFScoreNode[0] && goal[1] === minFScoreNode[1]) {\r\n      //   console.log(\"compeed the astar\");\r\n      console.log(cameFrom);\r\n      //   return constructPath(cameFrom, END_ROW, END_COLUMN, START_ROW, START_COL);\r\n      return { parent, visitedNodes };\r\n    }\r\n    const x = minFScoreNode[0];\r\n    const y = minFScoreNode[1];\r\n    visitedNodes.push([x, y]);\r\n    let newx = x + 1;\r\n    let newy = y;\r\n    if (newx < NUMBER_OF_ROW) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        //   console.log(\"tent_score\", tent_score);\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy,currentHeuristic);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"U\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n            // console.log(\"f\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // console.log(newx, NUMBER_OF_ROW);\r\n\r\n    newx = x - 1;\r\n    newy = y;\r\n    if (newx >= 0) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"D\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    newx = x;\r\n    newy = y - 1;\r\n    if (newy >= 0) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"R\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    newx = x;\r\n    newy = y + 1;\r\n    if (newy < NUMBER_OF_COL) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy,currentHeuristic);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"L\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // for (let row = 0; row < NUMBER_OF_ROW ; row++) {\r\n    //   for (let col = 0; col < NUMBER_OF_COL ; col++) {\r\n    //     if (fScore[row][col]<currentminFScoreValue){\r\n    //         currentminFScoreValue=  fScore[row][col];\r\n    //         minFScoreNode = [row,col];\r\n    //     }\r\n    //   }\r\n    // }\r\n  }\r\n  return { parent: -1, visitedNodes };\r\n};\r\n\r\n// const astar = (\r\n//   START_ROW,\r\n//   START_COL,\r\n//   END_ROW,\r\n//   END_COLUMN,\r\n//   grid,\r\n//   NUMBER_OF_COL,\r\n//   NUMBER_OF_ROW\r\n// ) => {};\r\n\r\nexport default astar;\r\n","// START_ROW,\r\n//   START_COL,\r\n//   END_ROW,\r\n//   END_COLUMN,\r\n//   grid,\r\n//   NUMBER_OF_COL,\r\n//   NUMBER_OF_ROW,\r\n//   currentHeuristic\r\nimport manhattan from \"../Heuristic/manhattan\";\r\nimport chebyshev from \"../Heuristic/chebyshev\";\r\nimport octile from \"../Heuristic/octile\";\r\nimport euclidean from \"../Heuristic/euclidean\";\r\n\r\nconst heuristic = (END_ROW, END_COL, CUR_ROW, CUR_COL, currentHeuristic) => {\r\n  // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  // console.log(\"currentHeuristic\",currentHeuristic);\r\n  if (currentHeuristic == \"Manhattan\") {\r\n    // console.log(\"in manhattan\");\r\n    const ans = manhattan(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n    return ans;\r\n    // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  }\r\n  if (currentHeuristic == \"Chebyshev\") {\r\n    return chebyshev(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Octile\") {\r\n    return octile(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Euclidean\") {\r\n    return euclidean(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n};\r\n\r\nclass Node {\r\n  constructor(parent, position) {\r\n    this.parent = parent;\r\n    this.position = position;\r\n    this.g = 0;\r\n    this.h = 0;\r\n    this.f = 0;\r\n  }\r\n  isEqual(other) {\r\n    if (\r\n      this.position[0] === other.position[0] &&\r\n      this.position[1] === other.position[1]\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nconst return_path = (current_node, grid, NUMBER_OF_ROW, NUMBER_OF_COL) => {\r\n  let path = [];\r\n  let result = [];\r\n  for (let index = 0; index < NUMBER_OF_ROW; index++) {\r\n    let roww = [];\r\n    for (let j = 0; j < NUMBER_OF_COL; j++) {\r\n      roww.push(\"N\");\r\n    }\r\n    result.push(roww);\r\n  }\r\n  let current = current_node;\r\n\r\n  while (current !== undefined) {\r\n    path.push(current.position);\r\n    // console.log(current);\r\n    if (current.parent == undefined) break;\r\n    const pr = current.parent.position[0];\r\n    const pc = current.parent.position[1];\r\n\r\n    const cr = current.parent.position[0];\r\n    const cc = current.parent.position[1];\r\n\r\n    if (cr === pr) {\r\n      if (pc + 1 === cc) {\r\n        result[cr][cc] = \"U\";\r\n      } else {\r\n        result[cr][cc] = \"D\";\r\n      }\r\n    }\r\n    if (cc == pc) {\r\n      if (cr + 1 == pr) {\r\n        result[cr][cc] = \"L\";\r\n      } else {\r\n        result[cr][cc] = \"R\";\r\n      }\r\n    }\r\n    current = current.parent;\r\n  }\r\n  //   console.log(path);\r\n  return path;\r\n};\r\n\r\nexport function astar2(\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW,\r\n  currentHeuristic\r\n) {\r\n  let start_node = new Node(undefined, [START_ROW, START_COL]);\r\n  start_node.g = 0;\r\n  start_node.f = 0;\r\n  start_node.h = 0;\r\n\r\n  let end_node = new Node(undefined, [END_ROW, END_COLUMN]);\r\n  end_node.g = 0;\r\n  end_node.f = 0;\r\n  end_node.h = 0;\r\n\r\n  let yet_to_visit_list = [];\r\n  let visited_list = [];\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  yet_to_visit_list.push(start_node);\r\n\r\n  let outer_iterations = 0;\r\n  let max_iterations = 10;\r\n  let move = [\r\n    [-1, 0],\r\n    [0, -1],\r\n    [1, 0],\r\n    [0, 1],\r\n  ];\r\n  while (yet_to_visit_list.length !== 0) {\r\n    outer_iterations += 1;\r\n    let current_node = yet_to_visit_list[0];\r\n    let current_index = 0;\r\n    for (let i = 0; i < yet_to_visit_list.length; i++) {\r\n      let index = i;\r\n      let item = yet_to_visit_list[i];\r\n      if (item.f < current_node.f) {\r\n        current_node = item;\r\n        current_index = index;\r\n      }\r\n    }\r\n    if (outer_iterations > max_iterations * 10000) {\r\n      alert(\"too many iterations\");\r\n      return { path: -1, visitedNodesInOrder };\r\n    }\r\n    // yet_to_visit_list.filter((thing) => thing!==current_node);\r\n\r\n    let newyettovisitlist = [];\r\n    for (let indexxx = 0; indexxx < yet_to_visit_list.length; indexxx++) {\r\n      if (indexxx !== current_index) {\r\n        newyettovisitlist.push(yet_to_visit_list[indexxx]);\r\n      }\r\n    }\r\n    yet_to_visit_list = [];\r\n    for (let indexxx = 0; indexxx < newyettovisitlist.length; indexxx++) {\r\n      yet_to_visit_list.push(newyettovisitlist[indexxx]);\r\n    }\r\n    visited_list.push(current_node);\r\n    // console.log(end_node);\r\n    // if ((current_node.position[0] === end_node.position[0]) && (current_node.position[1] === end_node.position[1])) {\r\n    if (end_node.isEqual(current_node)) {\r\n      // console.log(\"current_node\",current_node.row,current_node.col);\r\n      // console.log(\"end_node\",end_node.row,end_node.col);\r\n      return {\r\n        path: return_path(current_node, grid, NUMBER_OF_ROW, NUMBER_OF_COL),\r\n        visitedNodesInOrder,\r\n      };\r\n    }\r\n\r\n    let childrens = [];\r\n\r\n    for (let indexx = 0; indexx < move.length; indexx++) {\r\n      const new_position = move[indexx];\r\n      let nodeposition = [\r\n        current_node.position[0] + new_position[0],\r\n        current_node.position[1] + new_position[1],\r\n      ];\r\n      if (\r\n        nodeposition[0] >= NUMBER_OF_ROW ||\r\n        nodeposition[0] < 0 ||\r\n        nodeposition[1] >= NUMBER_OF_COL ||\r\n        nodeposition[1] < 0\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (grid[nodeposition[0]][nodeposition[1]].isWall === true) continue;\r\n      let new_node = new Node(current_node, nodeposition);\r\n      childrens.push(new_node);\r\n    }\r\n\r\n    for (let indexx = 0; indexx < childrens.length; indexx++) {\r\n      const child = childrens[indexx];\r\n\r\n      if (visited_list.includes(child)) continue;\r\n      child.g = current_node.g + 1;\r\n\r\n      child.h =\r\n        Math.pow(END_COLUMN - child.position[1], 2) +\r\n        Math.pow(END_ROW - child.position[0], 2);\r\n\r\n      //   child.h = heuristic(\r\n      //     END_ROW,\r\n      //     END_COLUMN,\r\n      //     child.row,\r\n      //     child.col,\r\n      //     currentHeuristic\r\n      //   );\r\n      child.f = child.g + child.h;\r\n      let flag = 0;\r\n      for (let j = 0; j < yet_to_visit_list.length; j++) {\r\n        const element = yet_to_visit_list[j];\r\n        if (child.isEqual(element) && child.g > element.g) {\r\n          flag = 1;\r\n          break;\r\n        }\r\n      }\r\n      if (flag === 1) continue;\r\n        console.log(child.position,child.f,child.g,child.h);\r\n      visitedNodesInOrder.push(child.position);\r\n      yet_to_visit_list.push(child);\r\n    }\r\n  }\r\n}\r\nexport default astar2;\r\n","function randomMaze(\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL,\r\n  NUMBER_OF_ROW,\r\n  NUMBER_OF_COL\r\n) {\r\n  //   if (!startNode || !finishNode || startNode === finishNode) {\r\n  //     return false;\r\n  //   }\r\n\r\n  let newGrid = grid.slice();\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    if (row == START_ROW && (0 == START_COL || START_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    if (row == END_ROW && (0 == END_COL || END_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    newGrid[row][0].isWall = true;\r\n    newGrid[row][NUMBER_OF_COL - 1].isWall = true;\r\n  }\r\n  for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n    if (col == START_COL && (0 == START_ROW || START_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    if (col == END_COL && (0 == END_ROW || END_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    newGrid[0][col].isWall = true;\r\n    newGrid[NUMBER_OF_ROW - 1][col].isWall = true;\r\n  }\r\n  let walls = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      if (\r\n        (row === START_ROW && col === START_COL) ||\r\n        (row === END_ROW && col === END_COL)\r\n      )\r\n        continue;\r\n      if (Math.random() < 0.33) {\r\n        walls.push([row, col]);\r\n        newGrid[row][col].isWall = true;\r\n      }\r\n    }\r\n  }\r\n  walls.sort(() => Math.random() - 0.5);\r\n  return { walls, newGrid };\r\n}\r\nexport default randomMaze;\r\n","function randomNumber(min, max) { \r\n    return Math.floor(Math.random() * (max - min) + min);\r\n} \r\n\r\nconst verticalMaze = (grid,START_ROW,START_COL , END_ROW, END_COL,NUMBER_OF_ROW,NUMBER_OF_COL) => {\r\n    let newGrid = grid.slice();\r\n    for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n        if (row==START_ROW && (0==START_COL || START_COL==NUMBER_OF_COL-1)) continue;\r\n        if (row==END_ROW && (0==END_COL || END_COL==NUMBER_OF_COL-1)) continue;\r\n        newGrid[row][0].isWall = true;\r\n        newGrid[row][NUMBER_OF_COL-1].isWall = true;\r\n    }\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n        if (col==START_COL && (0==START_ROW || START_ROW==NUMBER_OF_ROW-1)) continue;\r\n        if (col==END_COL && (0==END_ROW || END_ROW ==NUMBER_OF_ROW-1)) continue;\r\n        newGrid[0][col].isWall=true;\r\n        newGrid[NUMBER_OF_ROW-1][col].isWall=true;\r\n    }\r\n    for (let row=0;row<NUMBER_OF_ROW;row++){\r\n        \r\n        if (row%2===1) continue;\r\n        let random = randomNumber(0,NUMBER_OF_COL);\r\n        if (row===START_ROW || row===END_ROW){\r\n            if (START_ROW===END_ROW){\r\n                for (let col=0;col<NUMBER_OF_COL;col++){\r\n                    if (col!==START_COL && col!==END_COL){\r\n                        // console.log(newGrid);\r\n                        newGrid[row][col].isWall = true;\r\n                        // console.log(newGrid[row][col].isWall )\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            while(random!==START_COL && random!==END_COL){\r\n                random = randomNumber(0,NUMBER_OF_COL);\r\n            }\r\n            // if (row===END_ROW){\r\n            //     if (random===END_COL){\r\n            //         random = randomNumber(0,NUMBER_OF_COL);\r\n            //     }\r\n            // }\r\n            // if (row===START_ROW){\r\n            //     if (random===START_COL){\r\n            //         random = randomNumber(0,NUMBER_OF_COL);\r\n            //     }\r\n            // }\r\n        }\r\n        \r\n        for (let col=0;col<NUMBER_OF_COL;col++){\r\n            if (col!==random){\r\n                // console.log(newGrid);\r\n                newGrid[row][col].isWall = true;\r\n                // console.log(newGrid[row][col].isWall )\r\n            }\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nexport default verticalMaze;","// recursiveDivision\r\n\r\nlet walls;\r\nfunction recursiveDivision(\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL,\r\n  NUMBER_OF_ROW,\r\n  NUMBER_OF_COL\r\n) {\r\n  let vertical = [];\r\n  let horizontal = [];\r\n\r\n  for (let row = 1; row < grid.length; row++) horizontal.push(row);\r\n  for (let col = 1; col < grid[0].length; col++) vertical.push(col);\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    if (row == START_ROW && (0 == START_COL || START_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    if (row == END_ROW && (0 == END_COL || END_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    grid[row][0].isWall = true;\r\n    grid[row][NUMBER_OF_COL - 1].isWall = true;\r\n  }\r\n  for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n    if (col == START_COL && (0 == START_ROW || START_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    if (col == END_COL && (0 == END_ROW || END_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    grid[0][col].isWall = true;\r\n    grid[NUMBER_OF_ROW - 1][col].isWall = true;\r\n  }\r\n  NUMBER_OF_COL -= 1;\r\n  NUMBER_OF_ROW -= 1;\r\n  walls = [];\r\n  rec(vertical, horizontal, grid, START_ROW, START_COL, END_ROW, END_COL);\r\n  console.log(\"grid\", grid);\r\n  return grid;\r\n}\r\n\r\nconst rec = (\r\n  vertical,\r\n  horizontal,\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL\r\n) => {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let direction = 0;\r\n  let number = 0;\r\n  if (vertical.length > horizontal.length) {\r\n    direction = 0;\r\n    number = generateOddRandomNumber(vertical);\r\n  } else {\r\n    direction = 1;\r\n    number = generateOddRandomNumber(horizontal);\r\n  }\r\n  if (direction === 0) {\r\n    addWall(\r\n      direction,\r\n      number,\r\n      grid,\r\n      vertical,\r\n      horizontal,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical.slice(0, vertical.indexOf(number)),\r\n      horizontal,\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical.slice(vertical.indexOf(number) + 1),\r\n      horizontal,\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n  } else {\r\n    addWall(\r\n      direction,\r\n      number,\r\n      grid,\r\n      vertical,\r\n      horizontal,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(number)),\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(number) + 1),\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n  }\r\n};\r\n\r\nfunction addWall(\r\n  dir,\r\n  num,\r\n  grid,\r\n  vertical,\r\n  horizontal,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL\r\n) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (temp === START_ROW && num === START_COL) ||\r\n        (temp === END_ROW && num === END_COL)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (temp === START_ROW && num === START_COL) ||\r\n        (temp === END_ROW && num === END_COL)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n    if (wall == undefined) continue;\r\n    // console.log(\"wall\",wall);\r\n    // console.log(\"wall[0]\",wall[0]);\r\n\r\n    grid[wall[0]][wall[1]].isWall = true;\r\n  }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}\r\nfunction generateOddRandomNumber(array) {\r\n  let max = array.length - 1;\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return array[randomNum];\r\n}\r\n\r\nexport default recursiveDivision;\r\n","import React, { Component } from \"react\";\r\n\r\nimport nodesInShortestPath from \"../helper functions/nodesInShortestPath\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\r\n\r\nimport Popup from \"reactjs-popup\";\r\nimport \"reactjs-popup/dist/index.css\";\r\n\r\nimport Node from \"./Node/Node\";\r\n\r\nimport \"./PathFinding.css\";\r\n\r\nimport bfs from \"../algorithms/bfs\";\r\nimport dfs from \"../algorithms/dfs\";\r\nimport astar from \"../algorithms/astar\";\r\nimport astar2 from \"../algorithms/astar2\";\r\n\r\nimport randomMaze from \"../Maze/randomMazeGen\";\r\nimport verticalMaze from \"../Maze/verticalMaze\";\r\nimport recursiveDivision from \"../Maze/recursiveDivision\";\r\n\r\n//constants\r\nlet START_ROW = 10;\r\nlet START_COL = 10;\r\nlet END_ROW = 10;\r\nlet END_COLUMN = 31;\r\n\r\nconst NUMBER_OF_ROW = 25;\r\nconst NUMBER_OF_COL = 60;\r\n\r\nexport default class PathFinding extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      currentAlgo: \"BFS\",\r\n      mousePressedTarget: false,\r\n      mousePressedSource: false,\r\n      currentHeuristic: \"Manhattan\",\r\n      msgDisplay: \"none\",\r\n      msgOpacity: 0,\r\n      timeTaken: 0,\r\n      currentMaze: \"recDiv\",\r\n      shortestPathAstar: false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(false, [], false);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  //mouse events\r\n  handleMouseDown(row, col) {\r\n    this.clearPath();\r\n    if (row === END_ROW && col === END_COLUMN) {\r\n      this.setState({ mousePressedTarget: true });\r\n      return;\r\n    }\r\n    if (row === START_ROW && col === START_COL) {\r\n      this.setState({ mousePressedSource: true });\r\n      return;\r\n    }\r\n\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    if (col === END_COLUMN && row === END_ROW) {\r\n      this.setState({ grid: this.state.grid, mouseIsPressed: true });\r\n    } else {\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n  handleMouseEnter(row, col) {\r\n    // console.log(\"mouse enter\");\r\n    if (this.state.mousePressedTarget === true) {\r\n      if (row === START_ROW && col === START_COL) {\r\n        return;\r\n      }\r\n      const newGrid = getNewGridWithTargetChanged(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      END_COLUMN = col;\r\n      END_ROW = row;\r\n      return;\r\n    }\r\n    // mousePressedSource\r\n    if (this.state.mousePressedSource === true) {\r\n      if (row === END_ROW && col === END_COLUMN) {\r\n        return;\r\n      }\r\n      const newGrid = getNewGridWithSourceChanged(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      START_COL = col;\r\n      START_ROW = row;\r\n      return;\r\n    }\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (col === END_COLUMN && row === END_ROW) {\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n  handleMouseUp() {\r\n    // console.log(\"mouse up\");\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n      mousePressedTarget: false,\r\n      mousePressedSource: false,\r\n    });\r\n  }\r\n  displayMsg = () => {\r\n    // console.log()\r\n    this.setState({ msgDisplay: \"block\", msgOpacity: 1 });\r\n    setTimeout(() => {\r\n      this.setState({ msgDisplay: \"none\", msgOpacity: 0 });\r\n    }, 5000);\r\n  };\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder, algo) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        if (nodesInShortestPathOrder === -1) {\r\n          return;\r\n        }\r\n        this.displayMsg();\r\n        if (algo == \"astar2\") {\r\n          setTimeout(() => {\r\n            this.drawArrowsASTAR(nodesInShortestPathOrder);\r\n          }, 10 * i);\r\n        }\r\n        if (algo === \"DFS\") {\r\n          setTimeout(() => {\r\n            this.animateShortestPath(visitedNodesInOrder);\r\n          }, 5 * i);\r\n        } else {\r\n          setTimeout(() => {\r\n            this.animateShortestPath(nodesInShortestPathOrder);\r\n          }, 5 * i);\r\n        }\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 5 * i);\r\n        return;\r\n      }\r\n      //ss\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = true;\r\n        this.setState({ newGrid });\r\n      }, 1* i);\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = false;\r\n        newGrid[end_row][end_col].inPath = true;\r\n\r\n        this.setState({ newGrid });\r\n      }, 5 * i);\r\n    }\r\n  }\r\n\r\n  //this function makes the inshortestpath properity of the row and column true and uses setTimeout\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = false;\r\n        newGrid[end_row][end_col].inPath = false;\r\n        newGrid[end_row][end_col].inShortestPath = true;\r\n        this.setState({ newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //function for resetting the grid\r\n  resetGrid = () => {\r\n    const grid = getInitialGrid(false, [], false);\r\n    this.setState({ grid });\r\n  };\r\n  drawArrowsASTAR = (path) => {\r\n    for (let indexx = 0; indexx < path.length; indexx++) {\r\n      let newGrid = this.state.grid;\r\n      newGrid[path[indexx][0]][path[indexx][1]].shortestPathAstar = true;\r\n      this.setState({ grid: newGrid });\r\n    }\r\n  };\r\n\r\n  drawArrows = (parent) => {\r\n    let end_row = END_ROW;\r\n    let end_col = END_COLUMN;\r\n    while (end_row !== START_ROW || end_col !== START_COL) {\r\n      // let newGrid = this.state.grid;\r\n      // newGrid[end_row][end_col].direction = parent[end_row][end_col];\r\n      // this.setState({ newGrid });\r\n\r\n      if (parent[end_row][end_col] == \"U\") {\r\n        end_row -= 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"U\";\r\n        this.setState({ newGrid });\r\n      } else if (parent[end_row][end_col] == \"D\") {\r\n        end_row += 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"D\";\r\n        this.setState({ newGrid });\r\n      } else if (parent[end_row][end_col] == \"L\") {\r\n        end_col -= 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"L\";\r\n        this.setState({ newGrid });\r\n      } else {\r\n        end_col += 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"R\";\r\n        this.setState({ newGrid });\r\n      }\r\n    }\r\n  };\r\n\r\n  parent = -1;\r\n  visualizeAlgo = () => {\r\n    this.clearPath();\r\n    let tempGrid = this.state.grid;\r\n    tempGrid[START_ROW][START_COL].isWall = false;\r\n    tempGrid[END_ROW][END_COLUMN].isWall = false;\r\n    const prevTime = performance.now();\r\n\r\n    if (this.state.currentAlgo === \"ASTAR2\") {\r\n      const currentHeuristic = this.state.currentHeuristic;\r\n      // console.log(END_ROW,END_COLUMN)\r\n      const { path, visitedNodesInOrder } = astar2(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW,\r\n        currentHeuristic\r\n      );\r\n      // for (let indexx = 0; indexx < path.length; indexx++) {\r\n      //   let newGrid = this.state.grid;\r\n      //   newGrid[path[indexx][0]][path[indexx][1]].shortestPathAstar = true;\r\n      //   this.setState({grid:newGrid})\r\n      // }\r\n      // this.drawArrowsASTAR(path);\r\n      this.animateAlgo(visitedNodesInOrder, path, \"astar2\");\r\n      // this.animateAlgo(path, path, \"BFS\");\r\n    }\r\n\r\n    if (this.state.currentAlgo === \"ASTAR\") {\r\n      // console.log(\"this.state.currentHeuristic\", this.state.currentHeuristic);\r\n      // alert(\"ASTAR is wrong\")\r\n      const currentHeuristic = this.state.currentHeuristic;\r\n      const { parent, visitedNodes } = astar(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW,\r\n        currentHeuristic\r\n      );\r\n      const finalTime = performance.now();\r\n      this.setState({ timeTaken: finalTime - prevTime });\r\n      // console.log(parent);\r\n      let nodesInShortestPathOrder = [];\r\n      // console.log(parent);\r\n      if (parent !== -1 && parent != undefined) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodes, nodesInShortestPathOrder, \"BFS\");\r\n    }\r\n    if (this.state.currentAlgo == \"BFS\") {\r\n      let { parent, visitedNodesInOrder } = bfs(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW\r\n      );\r\n\r\n      const finalTime = performance.now();\r\n      this.setState({ timeTaken: finalTime - prevTime });\r\n      let nodesInShortestPathOrder = -1;\r\n      if (parent !== -1) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder, \"BFS\");\r\n    } else if (this.state.currentAlgo === \"DFS\") {\r\n      console.log(\"in dfs\");\r\n      let { parent, visitedNodesInOrder } = dfs(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW\r\n      );\r\n      const finalTime = performance.now();\r\n      this.setState({ timeTaken: finalTime - prevTime });\r\n      // console.log(\"visitedNodesInOrder\",visitedNodesInOrder);\r\n      let nodesInShortestPathOrder = -1;\r\n      if (parent !== -1) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodesInOrder, visitedNodesInOrder, \"DFS\");\r\n    }\r\n  };\r\n\r\n  clearPath = () => {\r\n    this.setState({ grid: getInitialGrid(true, this.state.grid, false) });\r\n  };\r\n\r\n  generateMaze = (currentMaze) => {\r\n    let tempGrid = this.state.grid;\r\n    tempGrid[START_ROW][START_COL].isStart = false;\r\n    START_ROW = 1;\r\n    START_COL = 1;\r\n    tempGrid[START_ROW][START_COL].isStart = true;\r\n    tempGrid[END_ROW][END_COLUMN].isFinish = false;\r\n    END_COLUMN = NUMBER_OF_COL - 2;\r\n    END_ROW = NUMBER_OF_ROW - 2;\r\n    tempGrid[END_ROW][END_COLUMN].isFinish = true;\r\n    this.setState({ grid: tempGrid });\r\n    this.setState({ grid: getInitialGrid(true, this.state.grid, true) });\r\n\r\n    if (currentMaze === \"recDiv\") {\r\n      const newGrid = recursiveDivision(\r\n        this.state.grid,\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        NUMBER_OF_ROW,\r\n        NUMBER_OF_COL\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (currentMaze === \"randomMaze\") {\r\n      let { walls, newGrid } = randomMaze(\r\n        this.state.grid,\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        NUMBER_OF_ROW,\r\n        NUMBER_OF_COL\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (currentMaze === \"verticalMaze\") {\r\n      const newGrid = verticalMaze(\r\n        this.state.grid,\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        NUMBER_OF_ROW,\r\n        NUMBER_OF_COL\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (currentMaze === \"horzMaze\") {\r\n      const newGrid = verticalMaze(\r\n        this.state.grid,\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        NUMBER_OF_ROW,\r\n        NUMBER_OF_COL\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    }\r\n\r\n    //for random Maze\r\n    // this.setState({ grid: getInitialGrid(true, this.state.grid,true) });\r\n    // let {walls,newGrid} = randomMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n    // console.log(\"returned grid\",newGrid)\r\n    // this.setState({grid:newGrid});\r\n    // console.log(this.state.grid);\r\n  };\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    return (\r\n      <div className=\"containerr\">\r\n        <div className=\"headerr\" style={{ marginBottom: 10 }}>\r\n          <div className=\"navbarr\">\r\n            <Navbar\r\n              style={{ fontSize: 17 }}\r\n              collapseOnSelect\r\n              expand=\"lg\"\r\n              bg=\"dark\"\r\n              variant=\"dark\"\r\n            >\r\n              <Navbar.Brand\r\n                style={{ fontSize: 30 }}\r\n                href=\"#home\"\r\n                // style={{ marginLeft: 4, fontSize: 35 }}\r\n              >\r\n                The PathFinder\r\n              </Navbar.Brand>\r\n              <Nav.Link\r\n                // style={{ marginRight: 10, fontSize: 25 }}\r\n                onClick={() => this.resetGrid()}\r\n              >\r\n                Reset Grid\r\n              </Nav.Link>\r\n              <Nav.Link\r\n                // style={{ marginRight: 10, fontSize: 25 }}\r\n                onClick={() => this.clearPath()}\r\n              >\r\n                Clear Path\r\n              </Nav.Link>\r\n\r\n              <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\r\n              <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n                <Nav className=\"mr-auto\">\r\n                  <NavDropdown\r\n                    title=\"Generate Maze\"\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"recDiv\")}\r\n                    >\r\n                      Recursive Division Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"randomMaze\")}\r\n                    >\r\n                      Random Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"verticalMaze\")}\r\n                    >\r\n                      Vertical Division Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"horzMaze\")}\r\n                    >\r\n                      Horizontal Division Maze\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n\r\n                  <NavDropdown\r\n                    title=\"Algorithms\"\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"BFS\" })}\r\n                    >\r\n                      Breath first search\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"DFS\" })}\r\n                    >\r\n                      Depth first search\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"ASTAR2\" })}\r\n                    >\r\n                      A*\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"DIJKSTRA\" })}\r\n                    >\r\n                      Dijkstra\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n                  <NavDropdown\r\n                    title={`Heuristic: ${this.state.currentHeuristic}`}\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Manhattan\" })\r\n                      }\r\n                    >\r\n                      Manhattan\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Euclidean\" })\r\n                      }\r\n                    >\r\n                      Euclidean\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Octile\" })\r\n                      }\r\n                    >\r\n                      Octile\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Chebyshev\" })\r\n                      }\r\n                    >\r\n                      Chebyshev\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n                  <Button\r\n                    onClick={() => this.visualizeAlgo()}\r\n                    // style={{ marginRight: 20, marginLeft: 20, fontSize: 20 }}\r\n                  >\r\n                    Visualize {this.state.currentAlgo}\r\n                  </Button>\r\n                </Nav>\r\n                <Nav></Nav>\r\n              </Navbar.Collapse>\r\n            </Navbar>\r\n          </div>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {this.state.grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isFinish,\r\n                    isStart,\r\n                    isWall,\r\n                    inPath,\r\n                    inPathFirst,\r\n                    inShortestPath,\r\n                    direction,\r\n                    shortestPathAstar,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      shortestPathAstar={shortestPathAstar}\r\n                      direction={direction}\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      inPath={inPath}\r\n                      inPathFirst={inPathFirst}\r\n                      inShortestPath={inShortestPath}\r\n                      isWall={isFinish || isStart ? false : isWall}\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <div\r\n          class=\"message\"\r\n          style={{\r\n            display: this.state.msgDisplay,\r\n            opacity: this.msgOpacity,\r\n            fontSize: 20,\r\n          }}\r\n        >\r\n          Time Taken: {Math.floor(this.state.timeTaken)} ms\r\n        </div>\r\n        {/* <div className=\"popupContainer\">\r\n            hey i am a popup\r\n          </div> */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (isClearPath, gridArg, resetWall) => {\r\n  if (isClearPath) {\r\n    let grid = gridArg;\r\n    for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n      for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n        // currentRow.push(createNode(col, row, isClearPath));\r\n\r\n        grid[row][col].isVisited = false;\r\n        if (resetWall) {\r\n          grid[row][col].isWall = false;\r\n        }\r\n        grid[row][col].shortestPathAstar = false;\r\n        grid[row][col].previousNode = null;\r\n        grid[row][col].inPath = false;\r\n        grid[row][col].inPathFirst = false;\r\n        grid[row][col].inShortestPath = false;\r\n        grid[row][col].direction = \"\";\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n  const grid = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(createNode(col, row, isClearPath));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row, isClearPath) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_ROW && col === START_COL,\r\n    isFinish: row === END_ROW && col === END_COLUMN,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    inPath: false,\r\n    inPathFirst: false,\r\n    inShortestPath: false,\r\n    direction: \"\",\r\n    shortestPathAstar: false,\r\n  };\r\n};\r\n\r\nconst getNewGridWithTargetChanged = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  newGrid[END_ROW][END_COLUMN].isFinish = false;\r\n  // newGrid[row][col].isWall = false;\r\n  newGrid[row][col].isFinish = true;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithSourceChanged = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  newGrid[START_ROW][START_COL].isStart = false;\r\n  // newGrid[row][col].isWall = false;\r\n  newGrid[row][col].isStart = true;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import './App.css';\nimport PathFinding from \"./PathFindingVisual/PathFinding\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div>\n        <PathFinding></PathFinding>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}