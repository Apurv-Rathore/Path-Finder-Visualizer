{"version":3,"sources":["helper functions/nodesInShortestPath.jsx","PathFindingVisual/Node/Node.jsx","algorithms/bfs.jsx","algorithms/dfs.jsx","Heuristic/manhattan.jsx","Heuristic/chebyshev.jsx","Heuristic/octile.jsx","Heuristic/euclidean.jsx","algorithms/astar.jsx","algorithms/astar2.jsx","Maze/randomMazeGen.jsx","Maze/verticalMaze.jsx","Maze/recursiveDivision.jsx","PathFindingVisual/PathFinding.jsx","App.js","reportWebVitals.js","index.js"],"names":["nodesInShortestPath","parent","START_ROW","START_COL","END_ROW","END_COLUMN","end_row","end_col","nodesInShortestPathOrder","push","reverse","console","log","Node","props","state","this","isFinish","isStart","inPath","inPathFirst","inShortestPath","isWall","onMouseDown","onMouseEnter","onMouseUp","row","col","direction","extraClassName","arrowClassName","className","Component","Queue","items","element","length","shift","bfs","grid","NUMBER_OF_COL","NUMBER_OF_ROW","visitedNodesInOrder","visited","currentRow","queue","enqueue","isEmpty","front","dequeue","x","y","dfs","stack","topStack","pop","manhattan","END_COL","CUR_ROW","CUR_COL","Math","abs","chebyshev","dy","dx","max","octile","min","euclidean","pow","heuristic","currentHeuristic","QueueElement","priority","PriorityQueue","queueElement","added","i","splice","str","astar","cameFrom","vis","gScore","fScore","visitedNodes","goal","minFScoreNode","newx","newy","tent_score","position","g","h","f","other","return_path","current_node","path","current","undefined","astar2","start_node","end_node","yet_to_visit_list","visited_list","move","current_index","index","item","newyettovisitlist","indexxx","isEqual","childrens","indexx","new_position","nodeposition","new_node","child","includes","flag","j","randomMaze","newGrid","slice","walls","random","sort","randomNumber","floor","verticalMaze","rec","vertical","horizontal","number","generateOddRandomNumber","addWall","indexOf","dir","num","isStartFinish","tempWalls","temp","randomNum","generateRandomNumber","wall","array","recursiveDivision","PathFinding","displayMsg","setState","msgDisplay","msgOpacity","setTimeout","resetGrid","getInitialGrid","drawArrows","visualizeAlgo","clearPath","tempGrid","prevTime","performance","now","currentAlgo","animateAlgo","alert","finalTime","timeTaken","generateMaze","currentMaze","mouseIsPressed","mousePressedTarget","mousePressedSource","getNewGridWithWallToggled","getNewGridWithTargetChanged","getNewGridWithSourceChanged","algo","animateShortestPath","node","style","marginBottom","Navbar","fontSize","collapseOnSelect","expand","bg","variant","Brand","href","Nav","Link","onClick","Toggle","aria-controls","Collapse","id","NavDropdown","title","Item","Button","map","rowIdx","nodeIdx","handleMouseUp","handleMouseDown","handleMouseEnter","class","display","opacity","isClearPath","gridArg","resetWall","isVisited","previousNode","createNode","distance","Infinity","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c4c4f0c8.chunk.js","sourcesContent":["const nodesInShortestPath = (\r\n  parent,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN\r\n) => {\r\n  // with the help of this function and the parent 2D array, we get the path from the source to the destination\r\n  // in the order\r\n\r\n  let end_row = END_ROW;\r\n  let end_col = END_COLUMN;\r\n  let nodesInShortestPathOrder = [];\r\n  while (end_row !== START_ROW || end_col !== START_COL) {\r\n    nodesInShortestPathOrder.push([end_row, end_col]);\r\n    if (parent[end_row][end_col] == \"U\") {\r\n      end_row -= 1;\r\n    } else if (parent[end_row][end_col] == \"D\") {\r\n      end_row += 1;\r\n    } else if (parent[end_row][end_col] == \"L\") {\r\n      end_col -= 1;\r\n    } else {\r\n      end_col += 1;\r\n    }\r\n  }\r\n  nodesInShortestPathOrder.push([end_row, end_col]);\r\n  nodesInShortestPathOrder.reverse();\r\n  console.log(nodesInShortestPathOrder);\r\n  return nodesInShortestPathOrder;\r\n};\r\n\r\nexport default nodesInShortestPath;\r\n","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  // componentDidMount()\r\n\r\n  render() {\r\n    const {\r\n      isFinish,\r\n      isStart,\r\n      inPath,\r\n      inPathFirst,\r\n      inShortestPath,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,col,\r\n      direction\r\n    } = this.props;\r\n\r\n    let extraClassName = \"\";\r\n    let arrowClassName = \"\";\r\n    // console.log(this.props);\r\n    // if (isFinishNode){\r\n    //     extraClassName = isFinishNode\r\n    // }\r\n    // console.log(isFinishNode)\r\n    if (inPath) {\r\n      extraClassName = \"inPath\";\r\n    }\r\n    if (inPathFirst) {\r\n      extraClassName = \"inPathFirst\";\r\n    }\r\n    if (inShortestPath) {\r\n      extraClassName = \"inShortestPath\";\r\n      if (direction==\"U\"){\r\n        arrowClassName = \"down\";\r\n      }\r\n      if (direction==\"D\"){\r\n        arrowClassName = \"up\";\r\n      }\r\n      if (direction==\"L\"){\r\n        arrowClassName = \"right\";\r\n      }\r\n      if (direction==\"R\"){\r\n        arrowClassName = \"left\";\r\n      }\r\n    }\r\n    if (isFinish) {\r\n        extraClassName = \"isFinish\";\r\n    } else if (isStart) {\r\n        extraClassName = \"isStart\";\r\n    }\r\n    if (isWall) {\r\n      extraClassName = \"isWall\";\r\n    }\r\n    return <div onMouseDown={() => onMouseDown(row, col)}\r\n    onMouseEnter={() => onMouseEnter(row, col)}\r\n    // draggable={true?extraClassName===\"isFinish\":false}\r\n    onMouseUp={() => onMouseUp()} className={`node ${extraClassName} ${arrowClassName}` }>\r\n      <div className={` ${arrowClassName}`}></div>\r\n      {/* <div\r\n      className = {`innode ${extraClassName} ${arrowClassName}`}\r\n      ></div> */}\r\n    </div>;\r\n  }\r\n}\r\n","class Queue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  // add element to the queue\r\n  enqueue(element) {\r\n    return this.items.push(element);\r\n  }\r\n\r\n  // remove element from the queue\r\n  dequeue() {\r\n    if (this.items.length > 0) {\r\n      return this.items.shift();\r\n    }\r\n  }\r\n\r\n  // check if the queue is empty\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  // empty the queue\r\n  clear() {\r\n    this.items = [];\r\n  }\r\n}\r\nconst bfs = (START_ROW, START_COL, END_ROW, END_COLUMN, grid,NUMBER_OF_COL,NUMBER_OF_ROW) => {\r\n  // console.log(END_ROW,END_COLUMN)\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  //making visited array\r\n  let visited = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    visited.push(currentRow);\r\n  }\r\n\r\n  //creating parent array to keep track of parent so that we can backtrack the steps\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW+1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL+1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  //making queue\r\n  let queue = new Queue();\r\n  queue.enqueue([START_ROW, START_COL]);\r\n  visited[START_ROW][START_COL] = true;\r\n  while (queue.isEmpty() == false) {\r\n    const front = queue.dequeue();\r\n    let x = front[0];\r\n    let y = front[1];\r\n    visitedNodesInOrder.push([x, y]);\r\n    if (x == END_ROW && y == END_COLUMN) {\r\n      return { parent, visitedNodesInOrder };\r\n    }\r\n    if (x + 1 < NUMBER_OF_ROW) {\r\n      x += 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"U\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      x -= 1;\r\n    }\r\n    if (x > 0) {\r\n      x -= 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"D\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      x += 1;\r\n    }\r\n    if (y + 1 < NUMBER_OF_COL) {\r\n      y += 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"L\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      y -= 1;\r\n    }\r\n    if (y > 0) {\r\n      y -= 1;\r\n      \r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          visited[x][y] = true;\r\n          parent[x][y] = \"R\";\r\n          queue.enqueue([x, y]);\r\n        }\r\n      }\r\n      y += 1;\r\n    }\r\n  }\r\n  return { parent:-1, visitedNodesInOrder };\r\n  \r\n};\r\nexport default bfs;\r\n","const dfs = (\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW\r\n) => {\r\n  // console.log(END_ROW,END_COLUMN)\r\n\r\n  let visitedNodesInOrder = [];\r\n\r\n  //making visited array\r\n  let visited = [];\r\n  for (let row = 0; row <= NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col <= NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    visited.push(currentRow);\r\n  }\r\n\r\n  //creating parent array to keep track of parent so that we can backtrack the steps\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW + 1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL + 1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  //making queue\r\n  //   let queue = new Queue();\r\n  let stack = [];\r\n  //   queue.enqueue([START_ROW, START_COL]);\r\n  stack.push([START_ROW, START_COL]);\r\n  //   visited[START_ROW][START_COL] = true;\r\n  while (stack.length !== 0) {\r\n    const topStack = stack.pop();\r\n    let x = topStack[0];\r\n    let y = topStack[1];\r\n    // console.log(\"vis\",x,y);\r\n    visited[x][y] = true;\r\n    visitedNodesInOrder.push([x, y]);\r\n\r\n    if (x == END_ROW && y == END_COLUMN) {\r\n      return { parent, visitedNodesInOrder };\r\n    }\r\n\r\n    if (y > 0) {\r\n      y -= 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"R\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      y += 1;\r\n    }\r\n\r\n    if (x + 1 < NUMBER_OF_ROW) {\r\n      x += 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"U\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      x -= 1;\r\n    }\r\n\r\n    if (y + 1 < NUMBER_OF_COL) {\r\n      y += 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"L\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      y -= 1;\r\n    }\r\n    if (x > 0) {\r\n      x -= 1;\r\n      if (grid[x][y].isWall == false) {\r\n        if (visited[x][y] == false) {\r\n          //   visited[x][y] = true;\r\n          parent[x][y] = \"D\";\r\n          stack.push([x, y]);\r\n        }\r\n      }\r\n      x += 1;\r\n    }\r\n  }\r\n  return { parent: -1, visitedNodesInOrder };\r\n};\r\nexport default dfs;\r\n","const manhattan = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n};\r\n\r\n\r\nexport default manhattan;","const chebyshev = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const dy = Math.abs(END_COL-CUR_COL);\r\n    const dx = Math.abs(END_ROW-CUR_ROW);\r\n    const distance = Math.max(dy,dx);\r\n    return distance;    \r\n};\r\n\r\n\r\nexport default chebyshev;","const octile = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const dy = Math.abs(END_COL-CUR_COL);\r\n    const dx = Math.abs(END_ROW-CUR_ROW);\r\n    const distance = 1.141 * (Math.min(dx,dy)) + Math.abs(dx-dy);\r\n    return distance;    \r\n};\r\n\r\n\r\nexport default octile;","const euclidean = (END_ROW, END_COL, CUR_ROW, CUR_COL) => {\r\n    const x = Math.abs(END_ROW-CUR_ROW)*Math.abs(END_ROW-CUR_ROW)\r\n    const y = Math.abs(END_COL-CUR_COL)*Math.abs(END_COL-CUR_COL)\r\n    const d = Math.pow(x+y,0.5);\r\n    return d;\r\n\r\n};\r\n\r\n\r\nexport default euclidean;","//importing heurstic\r\nimport manhattan from \"../Heuristic/manhattan\";\r\nimport chebyshev from \"../Heuristic/chebyshev\";\r\nimport octile from \"../Heuristic/octile\";\r\nimport euclidean from \"../Heuristic/euclidean\";\r\n\r\nconst heuristic = (END_ROW, END_COL, CUR_ROW, CUR_COL, currentHeuristic) => {\r\n  // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  // console.log(\"currentHeuristic\",currentHeuristic);\r\n  if (currentHeuristic == \"Manhattan\") {\r\n    // console.log(\"in manhattan\");\r\n    const ans =  manhattan(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n    return ans;\r\n    // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  }\r\n  if (currentHeuristic == \"Chebyshev\") {\r\n    return chebyshev(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Octile\") {\r\n    return octile(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Euclidean\") {\r\n    return euclidean(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n};\r\n\r\nconst constructPath = (cameFrom, er, ec, sr, sc) => {\r\n  let path = [];\r\n  let x = cameFrom[[er, ec]];\r\n  // console.log(c)\r\n  path.push(x);\r\n  while (x[0] != sr && x[1] != sc) {\r\n    x = cameFrom[x];\r\n    path.push(x);\r\n  }\r\n  return path;\r\n};\r\n\r\nclass QueueElement {\r\n  constructor(element, priority) {\r\n    this.element = element;\r\n    this.priority = priority;\r\n  }\r\n}\r\n\r\nclass PriorityQueue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  enqueue(element, priority) {\r\n    let queueElement = new QueueElement(element, priority);\r\n    let added = false;\r\n    for (let i = 0; i < this.items.length; i++) {\r\n      if (queueElement.priority < this.items[i].priority) {\r\n        this.items.splice(i, 0, queueElement);\r\n        added = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!added) {\r\n      this.items.push(queueElement);\r\n    }\r\n  }\r\n  dequeue() {\r\n    \r\n    return this.items.shift();\r\n  }\r\n\r\n  isEmpty() {\r\n    if (this.items.length === 0) return true;\r\n    return false;\r\n  }\r\n\r\n  printPQueue() {\r\n    var str = \"\";\r\n    for (var i = 0; i < this.items.length; i++)\r\n      str += this.items[i].element + \" \";\r\n    return str;\r\n  }\r\n\r\n  //   checkIfPresent(element){\r\n\r\n  //   }\r\n}\r\n\r\nconst astar = (\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW,\r\n  currentHeuristic\r\n) => {\r\n  let queue = new PriorityQueue();\r\n  let cameFrom = {};\r\n  let vis = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(false);\r\n    }\r\n    vis.push(currentRow);\r\n  }\r\n\r\n  let parent = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW + 1; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL + 1; col++) {\r\n      currentRow.push(\"N\");\r\n    }\r\n    parent.push(currentRow);\r\n  }\r\n\r\n  let gScore = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(100000000);\r\n    }\r\n    gScore.push(currentRow);\r\n  }\r\n  gScore[START_ROW][START_COL] = 0;\r\n\r\n  let fScore = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(100000000);\r\n    }\r\n    fScore.push(currentRow);\r\n  }\r\n  //   console.log(\"fScore\", fScore);\r\n  fScore[START_ROW][START_COL] = heuristic(\r\n    END_ROW,\r\n    END_COLUMN,\r\n    START_ROW,\r\n    START_COL,\r\n    currentHeuristic\r\n  );\r\n  //   let vis = {};\r\n  //   console.log(\"fScore\",fScore);\r\n  let visitedNodes = [];\r\n  queue.enqueue([START_ROW, START_COL], fScore[START_ROW][START_COL]);\r\n  vis[START_ROW][START_COL] = true;\r\n  const goal = [END_ROW, END_COLUMN];\r\n  //   console.log(\"f\");\r\n  while (queue.isEmpty() === false) {\r\n    // console.log(\"conetnets\",queue.printPQueue());\r\n    let minFScoreNode = queue.dequeue().element;\r\n    // console.log(minFScoreNode);\r\n    // console.log(\"compare\",minFScoreNode,goal)\r\n    if (goal[0] === minFScoreNode[0] && goal[1] === minFScoreNode[1]) {\r\n      //   console.log(\"compeed the astar\");\r\n      console.log(cameFrom);\r\n      //   return constructPath(cameFrom, END_ROW, END_COLUMN, START_ROW, START_COL);\r\n      return { parent, visitedNodes };\r\n    }\r\n    const x = minFScoreNode[0];\r\n    const y = minFScoreNode[1];\r\n    visitedNodes.push([x, y]);\r\n    let newx = x + 1;\r\n    let newy = y;\r\n    if (newx < NUMBER_OF_ROW) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        //   console.log(\"tent_score\", tent_score);\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy,currentHeuristic);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"U\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n            // console.log(\"f\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // console.log(newx, NUMBER_OF_ROW);\r\n\r\n    newx = x - 1;\r\n    newy = y;\r\n    if (newx >= 0) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"D\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    newx = x;\r\n    newy = y - 1;\r\n    if (newy >= 0) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"R\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    newx = x;\r\n    newy = y + 1;\r\n    if (newy < NUMBER_OF_COL) {\r\n      if (grid[newx][newy].isWall == false) {\r\n        const tent_score = gScore[x][y] + 1;\r\n        if (tent_score < gScore[newx][newy]) {\r\n          cameFrom[[newx, newy]] = [x, y];\r\n          gScore[newx][newy] = tent_score;\r\n          fScore[newx][newy] =\r\n            gScore[newx][newy] + heuristic(END_ROW, END_COLUMN, newx, newy,currentHeuristic);\r\n          if (vis[newx][newy] === false) {\r\n            vis[newx][newy] = true;\r\n            parent[newx][newy] = \"L\";\r\n            queue.enqueue([newx, newy], fScore[newx][newy]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // for (let row = 0; row < NUMBER_OF_ROW ; row++) {\r\n    //   for (let col = 0; col < NUMBER_OF_COL ; col++) {\r\n    //     if (fScore[row][col]<currentminFScoreValue){\r\n    //         currentminFScoreValue=  fScore[row][col];\r\n    //         minFScoreNode = [row,col];\r\n    //     }\r\n    //   }\r\n    // }\r\n  }\r\n  return { parent: -1, visitedNodes };\r\n};\r\n\r\n// const astar = (\r\n//   START_ROW,\r\n//   START_COL,\r\n//   END_ROW,\r\n//   END_COLUMN,\r\n//   grid,\r\n//   NUMBER_OF_COL,\r\n//   NUMBER_OF_ROW\r\n// ) => {};\r\n\r\nexport default astar;\r\n","// START_ROW,\r\n//   START_COL,\r\n//   END_ROW,\r\n//   END_COLUMN,\r\n//   grid,\r\n//   NUMBER_OF_COL,\r\n//   NUMBER_OF_ROW,\r\n//   currentHeuristic\r\nimport manhattan from \"../Heuristic/manhattan\";\r\nimport chebyshev from \"../Heuristic/chebyshev\";\r\nimport octile from \"../Heuristic/octile\";\r\nimport euclidean from \"../Heuristic/euclidean\";\r\n\r\nconst heuristic = (END_ROW, END_COL, CUR_ROW, CUR_COL, currentHeuristic) => {\r\n  // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  // console.log(\"currentHeuristic\",currentHeuristic);\r\n  if (currentHeuristic == \"Manhattan\") {\r\n    // console.log(\"in manhattan\");\r\n    const ans = manhattan(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n    return ans;\r\n    // return Math.abs(END_COL - CUR_COL) + Math.abs(END_ROW - CUR_ROW);\r\n  }\r\n  if (currentHeuristic == \"Chebyshev\") {\r\n    return chebyshev(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Octile\") {\r\n    return octile(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n  if (currentHeuristic == \"Euclidean\") {\r\n    return euclidean(END_ROW, END_COL, CUR_ROW, CUR_COL);\r\n  }\r\n};\r\n\r\nclass Node {\r\n  constructor(parent, position) {\r\n    this.parent = parent;\r\n    this.position = position;\r\n    this.g = 0;\r\n    this.h = 0;\r\n    this.f = 0;\r\n  }\r\n  isEqual(other) {\r\n    if (\r\n      this.position[0] === other.position[0] &&\r\n      this.position[1] === other.position[1]\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nconst return_path = (current_node, grid, NUMBER_OF_ROW, NUMBER_OF_COL) => {\r\n  let path = [];\r\n  let result = [];\r\n  // for (let index = 0; index < NUMBER_OF_ROW; index++) {\r\n  //     let roww = [];\r\n  //     for (let j = 0; j < NUMBER_OF_COL; j++) {\r\n  //         roww.push(-1);\r\n  //     }\r\n  //     result.push(roww);\r\n  // }\r\n  let current = current_node;\r\n\r\n  while (current !== undefined) {\r\n    path.push(current.position);\r\n    console.log(current);\r\n    current = current.parent;\r\n  }\r\n  console.log(path);\r\n  return path;\r\n};\r\n\r\nexport function astar2(\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COLUMN,\r\n  grid,\r\n  NUMBER_OF_COL,\r\n  NUMBER_OF_ROW,\r\n  currentHeuristic\r\n) {\r\n  let start_node = new Node(undefined, [START_ROW, START_COL]);\r\n  start_node.g = 0;\r\n  start_node.f = 0;\r\n  start_node.h = 0;\r\n\r\n  let end_node = new Node(undefined, [END_ROW, END_COLUMN]);\r\n  end_node.g = 0;\r\n  end_node.f = 0;\r\n  end_node.h = 0;\r\n\r\n  let yet_to_visit_list = [];\r\n  let visited_list = [];\r\n\r\n  yet_to_visit_list.push(start_node);\r\n\r\n  let outer_iterations = 0;\r\n  let max_iterations = 10;\r\n\r\n  let move = [\r\n    [-1, 0],\r\n    [0, -1],\r\n    [1, 0],\r\n    [0, 1],\r\n  ];\r\n\r\n  while (yet_to_visit_list.length !== 0) {\r\n    outer_iterations += 1;\r\n    let current_node = yet_to_visit_list[0];\r\n    let current_index = 0;\r\n    for (let i = 0; i < yet_to_visit_list.length; i++) {\r\n      let index = i;\r\n      let item = yet_to_visit_list[i];\r\n      if (item.f < current_node.f) {\r\n        current_node = item;\r\n        current_index = index;\r\n      }\r\n    }\r\n    // if (outer_iterations > max_iterations * 1000) {\r\n    //   alert(\"too many iterations\");\r\n    //   return [];\r\n    // }\r\n    // yet_to_visit_list.filter((thing) => thing!==current_node);\r\n\r\n    let newyettovisitlist = [];\r\n    for (let indexxx = 0; indexxx < yet_to_visit_list.length; indexxx++) {\r\n      if (indexxx !== current_index) {\r\n        newyettovisitlist.push(yet_to_visit_list[indexxx]);\r\n      }\r\n    }\r\n    yet_to_visit_list = [];\r\n    for (let indexxx = 0; indexxx < newyettovisitlist.length; indexxx++) {\r\n      yet_to_visit_list.push(newyettovisitlist[indexxx]);\r\n    }\r\n    visited_list.push(current_node);\r\n    console.log(end_node);\r\n    // if ((current_node.position[0] === end_node.position[0]) && (current_node.position[1] === end_node.position[1])) {\r\n    if (end_node.isEqual(current_node)) {\r\n      // console.log(\"current_node\",current_node.row,current_node.col);\r\n      // console.log(\"end_node\",end_node.row,end_node.col);\r\n      return return_path(current_node, grid, NUMBER_OF_ROW, NUMBER_OF_COL);\r\n    }\r\n\r\n    let childrens = [];\r\n\r\n    for (let indexx = 0; indexx < move.length; indexx++) {\r\n      const new_position = move[indexx];\r\n      let nodeposition = [\r\n        current_node.position[0] + new_position[0],\r\n        current_node.position[1] + new_position[1],\r\n      ];\r\n      if (\r\n        nodeposition[0] >= NUMBER_OF_ROW ||\r\n        nodeposition[0] < 0 ||\r\n        nodeposition[1] >= NUMBER_OF_COL ||\r\n        nodeposition[1] < 0\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (grid[nodeposition[0]][nodeposition[1]].isWall === true) continue;\r\n      let new_node = new Node(current_node, nodeposition);\r\n      childrens.push(new_node);\r\n    }\r\n\r\n    for (let indexx = 0; indexx < childrens.length; indexx++) {\r\n      const child = childrens[indexx];\r\n\r\n      if (visited_list.includes(child)) continue;\r\n      child.g = current_node.g + 1;\r\n      child.h = heuristic(\r\n        END_ROW,\r\n        END_COLUMN,\r\n        child.row,\r\n        child.col,\r\n        currentHeuristic\r\n      );\r\n      child.f = child.g + child.h;\r\n      let flag = 0;\r\n      for (let j = 0; j < yet_to_visit_list.length; j++) {\r\n        const element = yet_to_visit_list[j];\r\n        if ((child.isEqual(element)) && (child.g >= element.g)) {\r\n          flag = 1;\r\n          break;\r\n        }\r\n      }\r\n      if (flag === 1) continue;\r\n      console.log(child.position);\r\n      yet_to_visit_list.push(child);\r\n    }\r\n  }\r\n}\r\nexport default astar2;\r\n","function randomMaze(\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL,\r\n  NUMBER_OF_ROW,\r\n  NUMBER_OF_COL\r\n) {\r\n  //   if (!startNode || !finishNode || startNode === finishNode) {\r\n  //     return false;\r\n  //   }\r\n\r\n  let newGrid = grid.slice();\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    if (row == START_ROW && (0 == START_COL || START_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    if (row == END_ROW && (0 == END_COL || END_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    newGrid[row][0].isWall = true;\r\n    newGrid[row][NUMBER_OF_COL - 1].isWall = true;\r\n  }\r\n  for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n    if (col == START_COL && (0 == START_ROW || START_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    if (col == END_COL && (0 == END_ROW || END_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    newGrid[0][col].isWall = true;\r\n    newGrid[NUMBER_OF_ROW - 1][col].isWall = true;\r\n  }\r\n  let walls = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      if (\r\n        (row === START_ROW && col === START_COL) ||\r\n        (row === END_ROW && col === END_COL)\r\n      )\r\n        continue;\r\n      if (Math.random() < 0.33) {\r\n        walls.push([row, col]);\r\n        newGrid[row][col].isWall = true;\r\n      }\r\n    }\r\n  }\r\n  walls.sort(() => Math.random() - 0.5);\r\n  return { walls, newGrid };\r\n}\r\nexport default randomMaze;\r\n","function randomNumber(min, max) { \r\n    return Math.floor(Math.random() * (max - min) + min);\r\n} \r\n\r\nconst verticalMaze = (grid,START_ROW,START_COL , END_ROW, END_COL,NUMBER_OF_ROW,NUMBER_OF_COL) => {\r\n    let newGrid = grid.slice();\r\n    for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n        if (row==START_ROW && (0==START_COL || START_COL==NUMBER_OF_COL-1)) continue;\r\n        if (row==END_ROW && (0==END_COL || END_COL==NUMBER_OF_COL-1)) continue;\r\n        newGrid[row][0].isWall = true;\r\n        newGrid[row][NUMBER_OF_COL-1].isWall = true;\r\n    }\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n        if (col==START_COL && (0==START_ROW || START_ROW==NUMBER_OF_ROW-1)) continue;\r\n        if (col==END_COL && (0==END_ROW || END_ROW ==NUMBER_OF_ROW-1)) continue;\r\n        newGrid[0][col].isWall=true;\r\n        newGrid[NUMBER_OF_ROW-1][col].isWall=true;\r\n    }\r\n    for (let row=0;row<NUMBER_OF_ROW;row++){\r\n        \r\n        if (row%2===1) continue;\r\n        let random = randomNumber(0,NUMBER_OF_COL);\r\n        if (row===START_ROW || row===END_ROW){\r\n            if (START_ROW===END_ROW){\r\n                for (let col=0;col<NUMBER_OF_COL;col++){\r\n                    if (col!==START_COL && col!==END_COL){\r\n                        // console.log(newGrid);\r\n                        newGrid[row][col].isWall = true;\r\n                        // console.log(newGrid[row][col].isWall )\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            while(random!==START_COL && random!==END_COL){\r\n                random = randomNumber(0,NUMBER_OF_COL);\r\n            }\r\n            // if (row===END_ROW){\r\n            //     if (random===END_COL){\r\n            //         random = randomNumber(0,NUMBER_OF_COL);\r\n            //     }\r\n            // }\r\n            // if (row===START_ROW){\r\n            //     if (random===START_COL){\r\n            //         random = randomNumber(0,NUMBER_OF_COL);\r\n            //     }\r\n            // }\r\n        }\r\n        \r\n        for (let col=0;col<NUMBER_OF_COL;col++){\r\n            if (col!==random){\r\n                // console.log(newGrid);\r\n                newGrid[row][col].isWall = true;\r\n                // console.log(newGrid[row][col].isWall )\r\n            }\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nexport default verticalMaze;","// recursiveDivision\r\n\r\nlet walls;\r\nfunction recursiveDivision(\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL,\r\n  NUMBER_OF_ROW,\r\n  NUMBER_OF_COL\r\n) {\r\n  let vertical = [];\r\n  let horizontal = [];\r\n\r\n  for (let row = 1; row < grid.length; row++) horizontal.push(row);\r\n  for (let col = 1; col < grid[0].length; col++) vertical.push(col);\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    if (row == START_ROW && (0 == START_COL || START_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    if (row == END_ROW && (0 == END_COL || END_COL == NUMBER_OF_COL - 1))\r\n      continue;\r\n    grid[row][0].isWall = true;\r\n    grid[row][NUMBER_OF_COL - 1].isWall = true;\r\n  }\r\n  for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n    if (col == START_COL && (0 == START_ROW || START_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    if (col == END_COL && (0 == END_ROW || END_ROW == NUMBER_OF_ROW - 1))\r\n      continue;\r\n    grid[0][col].isWall = true;\r\n    grid[NUMBER_OF_ROW - 1][col].isWall = true;\r\n  }\r\n  NUMBER_OF_COL -= 1;\r\n  NUMBER_OF_ROW -= 1;\r\n  walls = [];\r\n  rec(vertical, horizontal, grid, START_ROW, START_COL, END_ROW, END_COL);\r\n  console.log(\"grid\", grid);\r\n  return grid;\r\n}\r\n\r\nconst rec = (\r\n  vertical,\r\n  horizontal,\r\n  grid,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL\r\n) => {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let direction = 0;\r\n  let number = 0;\r\n  if (vertical.length > horizontal.length) {\r\n    direction = 0;\r\n    number = generateOddRandomNumber(vertical);\r\n  } else {\r\n    direction = 1;\r\n    number = generateOddRandomNumber(horizontal);\r\n  }\r\n  if (direction === 0) {\r\n    addWall(\r\n      direction,\r\n      number,\r\n      grid,\r\n      vertical,\r\n      horizontal,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical.slice(0, vertical.indexOf(number)),\r\n      horizontal,\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical.slice(vertical.indexOf(number) + 1),\r\n      horizontal,\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n  } else {\r\n    addWall(\r\n      direction,\r\n      number,\r\n      grid,\r\n      vertical,\r\n      horizontal,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(number)),\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n    rec(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(number) + 1),\r\n      grid,\r\n      START_ROW,\r\n      START_COL,\r\n      END_ROW,\r\n      END_COL\r\n    );\r\n  }\r\n};\r\n\r\nfunction addWall(\r\n  dir,\r\n  num,\r\n  grid,\r\n  vertical,\r\n  horizontal,\r\n  START_ROW,\r\n  START_COL,\r\n  END_ROW,\r\n  END_COL\r\n) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (temp === START_ROW && num === START_COL) ||\r\n        (temp === END_ROW && num === END_COL)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (temp === START_ROW && num === START_COL) ||\r\n        (temp === END_ROW && num === END_COL)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n    if (wall == undefined) continue;\r\n    // console.log(\"wall\",wall);\r\n    // console.log(\"wall[0]\",wall[0]);\r\n\r\n    grid[wall[0]][wall[1]].isWall = true;\r\n  }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}\r\nfunction generateOddRandomNumber(array) {\r\n  let max = array.length - 1;\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return array[randomNum];\r\n}\r\n\r\nexport default recursiveDivision;\r\n","import React, { Component } from \"react\";\r\n\r\nimport nodesInShortestPath from \"../helper functions/nodesInShortestPath\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\r\n\r\nimport Popup from \"reactjs-popup\";\r\nimport \"reactjs-popup/dist/index.css\";\r\n\r\nimport Node from \"./Node/Node\";\r\n\r\nimport \"./PathFinding.css\";\r\n\r\nimport bfs from \"../algorithms/bfs\";\r\nimport dfs from \"../algorithms/dfs\";\r\nimport astar from \"../algorithms/astar\";\r\nimport astar2 from \"../algorithms/astar2\";\r\n\r\nimport randomMaze from \"../Maze/randomMazeGen\";\r\nimport verticalMaze from \"../Maze/verticalMaze\";\r\nimport recursiveDivision from \"../Maze/recursiveDivision\"\r\n\r\n//constants\r\nlet START_ROW = 10;\r\nlet START_COL = 10;\r\nlet END_ROW = 10;\r\nlet END_COLUMN = 31;\r\n\r\nconst NUMBER_OF_ROW = 25;\r\nconst NUMBER_OF_COL = 60;\r\n\r\nexport default class PathFinding extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      currentAlgo: \"BFS\",\r\n      mousePressedTarget: false,\r\n      mousePressedSource: false,\r\n      currentHeuristic: \"Manhattan\",\r\n      msgDisplay: \"none\",\r\n      msgOpacity: 0,\r\n      timeTaken: 0,\r\n      currentMaze: \"recDiv\"\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(false, [],false);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  //mouse events\r\n  handleMouseDown(row, col) {\r\n    this.clearPath();\r\n    if (row === END_ROW && col === END_COLUMN) {\r\n      this.setState({ mousePressedTarget: true });\r\n      return;\r\n    }\r\n    if (row === START_ROW && col === START_COL) {\r\n      this.setState({ mousePressedSource: true });\r\n      return;\r\n    }\r\n\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    if (col === END_COLUMN && row === END_ROW) {\r\n      this.setState({ grid: this.state.grid, mouseIsPressed: true });\r\n    } else {\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n  handleMouseEnter(row, col) {\r\n    // console.log(\"mouse enter\");\r\n    if (this.state.mousePressedTarget === true) {\r\n      if (row === START_ROW && col === START_COL) {\r\n        return;\r\n      }\r\n      const newGrid = getNewGridWithTargetChanged(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      END_COLUMN = col;\r\n      END_ROW = row;\r\n      return;\r\n    }\r\n    // mousePressedSource\r\n    if (this.state.mousePressedSource === true) {\r\n      if (row === END_ROW && col === END_COLUMN) {\r\n        return;\r\n      }\r\n      const newGrid = getNewGridWithSourceChanged(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      START_COL = col;\r\n      START_ROW = row;\r\n      return;\r\n    }\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (col === END_COLUMN && row === END_ROW) {\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n  handleMouseUp() {\r\n    // console.log(\"mouse up\");\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n      mousePressedTarget: false,\r\n      mousePressedSource: false,\r\n    });\r\n  }\r\n  displayMsg = () => {\r\n    // console.log()\r\n    this.setState({msgDisplay:\"block\", msgOpacity:1});\r\n    setTimeout(() => {\r\n      this.setState({msgDisplay:\"none\", msgOpacity:0});\r\n    },5000)\r\n  }\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder, algo) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        if (nodesInShortestPathOrder === -1) {\r\n          return;\r\n        }\r\n        this.displayMsg();\r\n        if (algo === \"DFS\") {\r\n          \r\n          setTimeout(() => {\r\n            this.animateShortestPath(visitedNodesInOrder);\r\n          }, 5 * i);\r\n        } else {\r\n          setTimeout(() => {\r\n            this.animateShortestPath(nodesInShortestPathOrder);\r\n          }, 5 * i);\r\n        }\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 5 * i);\r\n        return;\r\n      }\r\n      //ss\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = true;\r\n        this.setState({ newGrid });\r\n      }, 10*i);\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = false;\r\n        newGrid[end_row][end_col].inPath = true;\r\n\r\n        this.setState({ newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //this function makes the inshortestpath properity of the row and column true and uses setTimeout\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        const end_row = node[0];\r\n        const end_col = node[1];\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].inPathFirst = false;\r\n        newGrid[end_row][end_col].inPath = false;\r\n        newGrid[end_row][end_col].inShortestPath = true;\r\n        this.setState({ newGrid });\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  //function for resetting the grid\r\n  resetGrid = () => {\r\n    const grid = getInitialGrid(false, [],false);\r\n    this.setState({ grid });\r\n  };\r\n\r\n  drawArrows = (parent) => {\r\n    \r\n    let end_row = END_ROW;\r\n    let end_col = END_COLUMN;\r\n    while (end_row !== START_ROW || end_col !== START_COL) {\r\n      // let newGrid = this.state.grid;\r\n      // newGrid[end_row][end_col].direction = parent[end_row][end_col];\r\n      // this.setState({ newGrid });\r\n\r\n      if (parent[end_row][end_col] == \"U\") {\r\n        end_row -= 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"U\";\r\n        this.setState({ newGrid });\r\n      } else if (parent[end_row][end_col] == \"D\") {\r\n        end_row += 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"D\";\r\n        this.setState({ newGrid });\r\n      } else if (parent[end_row][end_col] == \"L\") {\r\n        end_col -= 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"L\";\r\n        this.setState({ newGrid });\r\n      } else {\r\n        end_col += 1;\r\n        if (end_col === START_COL && end_row === START_ROW) {\r\n          break;\r\n        }\r\n        let newGrid = this.state.grid;\r\n        newGrid[end_row][end_col].direction = \"R\";\r\n        this.setState({ newGrid });\r\n      }\r\n    }\r\n  };\r\n\r\n  parent = -1;\r\n  visualizeAlgo = () => {\r\n    this.clearPath();\r\n    let tempGrid = this.state.grid;\r\n    tempGrid[START_ROW][START_COL].isWall=false;\r\n    tempGrid[END_ROW][END_COLUMN].isWall=false;\r\n    const prevTime = performance.now();\r\n\r\n    if (this.state.currentAlgo===\"ASTAR2\"){\r\n      const currentHeuristic = this.state.currentHeuristic;\r\n      // console.log(END_ROW,END_COLUMN)\r\n      const path = astar2(START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW,\r\n        currentHeuristic);\r\n        // this.drawArrows(parent);\r\n        this.animateAlgo(path, path, \"BFS\");\r\n    }\r\n\r\n    if (this.state.currentAlgo === \"ASTAR\") {\r\n      // console.log(\"this.state.currentHeuristic\", this.state.currentHeuristic);\r\n      alert(\"ASTAR is wrong\")\r\n      const currentHeuristic = this.state.currentHeuristic;\r\n      const { parent, visitedNodes } = astar(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW,\r\n        currentHeuristic\r\n      );\r\n      const finalTime = performance.now();\r\n      this.setState({timeTaken:(finalTime-prevTime)});\r\n      // console.log(parent);\r\n      let nodesInShortestPathOrder = [];\r\n      // console.log(parent);\r\n      if (parent !== -1 && parent != undefined) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodes, nodesInShortestPathOrder, \"BFS\");\r\n    }\r\n    if (this.state.currentAlgo == \"BFS\") {\r\n      \r\n      \r\n      let { parent, visitedNodesInOrder } = bfs(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW\r\n      );\r\n      \r\n      const finalTime = performance.now();\r\n      this.setState({timeTaken:(finalTime-prevTime)});\r\n      let nodesInShortestPathOrder = -1;\r\n      if (parent !== -1) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder, \"BFS\");\r\n    } else if (this.state.currentAlgo === \"DFS\") {\r\n      console.log(\"in dfs\");\r\n      let { parent, visitedNodesInOrder } = dfs(\r\n        START_ROW,\r\n        START_COL,\r\n        END_ROW,\r\n        END_COLUMN,\r\n        this.state.grid,\r\n        NUMBER_OF_COL,\r\n        NUMBER_OF_ROW\r\n      );\r\n      const finalTime = performance.now();\r\n      this.setState({timeTaken:(finalTime-prevTime)});\r\n      // console.log(\"visitedNodesInOrder\",visitedNodesInOrder);\r\n      let nodesInShortestPathOrder = -1;\r\n      if (parent !== -1) {\r\n        nodesInShortestPathOrder = nodesInShortestPath(\r\n          parent,\r\n          START_ROW,\r\n          START_COL,\r\n          END_ROW,\r\n          END_COLUMN\r\n        );\r\n        this.drawArrows(parent);\r\n      }\r\n      this.animateAlgo(visitedNodesInOrder, visitedNodesInOrder, \"DFS\");\r\n    }\r\n  };\r\n\r\n  clearPath = () => {\r\n    this.setState({ grid: getInitialGrid(true, this.state.grid,false) });\r\n  };\r\n\r\n  generateMaze = (currentMaze) => {\r\n    let tempGrid = this.state.grid;\r\n    tempGrid[START_ROW][START_COL].isStart = false;\r\n    START_ROW = 1;\r\n    START_COL = 1;\r\n    tempGrid[START_ROW][START_COL].isStart = true;\r\n    tempGrid[END_ROW][END_COLUMN].isFinish=false;\r\n    END_COLUMN = NUMBER_OF_COL-2;\r\n    END_ROW = NUMBER_OF_ROW-2;\r\n    tempGrid[END_ROW][END_COLUMN].isFinish=true;\r\n    this.setState({grid:tempGrid});\r\n    this.setState({ grid: getInitialGrid(true, this.state.grid,true) });\r\n\r\n\r\n    if (currentMaze===\"recDiv\"){\r\n      const newGrid = recursiveDivision(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (currentMaze===\"randomMaze\"){\r\n      let {walls,newGrid} = randomMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (currentMaze===\"verticalMaze\"){\r\n      const newGrid = verticalMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (currentMaze===\"horzMaze\"){\r\n      const newGrid = verticalMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n      this.setState({grid:newGrid});\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //for random Maze\r\n    // this.setState({ grid: getInitialGrid(true, this.state.grid,true) });\r\n    // let {walls,newGrid} = randomMaze(this.state.grid,START_ROW,START_COL , END_ROW, END_COLUMN,NUMBER_OF_ROW,NUMBER_OF_COL);\r\n    // console.log(\"returned grid\",newGrid)\r\n    // this.setState({grid:newGrid});\r\n    // console.log(this.state.grid);\r\n  };\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    return (\r\n      <div className=\"containerr\">\r\n        <div className=\"headerr\" style={{ marginBottom: 10 }}>\r\n          <div className=\"navbarr\">\r\n            <Navbar style={{fontSize:17}} collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\">\r\n              <Navbar.Brand\r\n                style={{fontSize:30}}\r\n                href=\"#home\"\r\n                // style={{ marginLeft: 4, fontSize: 35 }}\r\n              >\r\n                The PathFinder\r\n              </Navbar.Brand>\r\n              <Nav.Link\r\n                // style={{ marginRight: 10, fontSize: 25 }}\r\n                onClick={() => this.resetGrid()}\r\n              >\r\n                Reset Grid\r\n              </Nav.Link>\r\n              <Nav.Link\r\n                // style={{ marginRight: 10, fontSize: 25 }}\r\n                onClick={() => this.clearPath()}\r\n              >\r\n                Clear Path\r\n              </Nav.Link>\r\n\r\n              \r\n              <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\r\n              <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n                <Nav className=\"mr-auto\">\r\n                  \r\n                  \r\n\r\n                  <NavDropdown\r\n                  \r\n                    title=\"Generate Maze\"\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"recDiv\")}\r\n                    >\r\n                      Recursive Division Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"randomMaze\")}\r\n                    >\r\n                      Random Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"verticalMaze\")}\r\n                    >\r\n                      Vertical Division Maze\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.generateMaze(\"horzMaze\")}\r\n                    >\r\n                      Horizontal Division Maze\r\n                    </NavDropdown.Item>\r\n                    \r\n                  </NavDropdown>\r\n\r\n\r\n                  <NavDropdown\r\n                    title=\"Algorithms\"\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"BFS\" })}\r\n                    >\r\n                      Breath first search\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"DFS\" })}\r\n                    >\r\n                      Depth first search\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"ASTAR2\" })}\r\n                    >\r\n                      A*\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() => this.setState({ currentAlgo: \"DIJKSTRA\" })}\r\n                    >\r\n                      Dijkstra\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n                  <NavDropdown\r\n                    title={`Heuristic: ${this.state.currentHeuristic}`}\r\n                    id=\"collasible-nav-dropdown\"\r\n                    // style={{ marginRight: 10, fontSize: 25, color: \"#0d6efd\" }}\r\n                  >\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Manhattan\" })\r\n                      }\r\n                    >\r\n                      Manhattan\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Euclidean\" })\r\n                      }\r\n                    >\r\n                      Euclidean\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Octile\" })\r\n                      }\r\n                    >\r\n                      Octile\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      onClick={() =>\r\n                        this.setState({ currentHeuristic: \"Chebyshev\" })\r\n                      }\r\n                    >\r\n                      Chebyshev\r\n                    </NavDropdown.Item>\r\n                  </NavDropdown>\r\n                  <Button\r\n              \r\n                onClick={() => this.visualizeAlgo()}\r\n                // style={{ marginRight: 20, marginLeft: 20, fontSize: 20 }}\r\n              >\r\n                Visualize {this.state.currentAlgo}\r\n              </Button>\r\n                </Nav>\r\n                <Nav></Nav>\r\n              </Navbar.Collapse>\r\n            </Navbar>\r\n          </div>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {this.state.grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isFinish,\r\n                    isStart,\r\n                    isWall,\r\n                    inPath,\r\n                    inPathFirst,\r\n                    inShortestPath,\r\n                    direction,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      direction={direction}\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      inPath={inPath}\r\n                      inPathFirst={inPathFirst}\r\n                      inShortestPath={inShortestPath}\r\n                      isWall={isFinish || isStart ? false : isWall}\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <div class=\"message\" style={{display:this.state.msgDisplay, opacity: this.msgOpacity, fontSize:20}}>Time Taken: {Math.floor(this.state.timeTaken)} ms</div>\r\n        {/* <div className=\"popupContainer\">\r\n            hey i am a popup\r\n          </div> */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (isClearPath, gridArg, resetWall) => {\r\n  if (isClearPath) {\r\n    let grid = gridArg;\r\n    for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n      for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n        // currentRow.push(createNode(col, row, isClearPath));\r\n\r\n        grid[row][col].isVisited = false;\r\n        if (resetWall){\r\n          grid[row][col].isWall =  false;\r\n        }\r\n        \r\n        grid[row][col].previousNode = null;\r\n        grid[row][col].inPath = false;\r\n        grid[row][col].inPathFirst = false;\r\n        grid[row][col].inShortestPath = false;\r\n        grid[row][col].direction = \"\";\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n  const grid = [];\r\n  for (let row = 0; row < NUMBER_OF_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUMBER_OF_COL; col++) {\r\n      currentRow.push(createNode(col, row, isClearPath));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row, isClearPath) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_ROW && col === START_COL,\r\n    isFinish: row === END_ROW && col === END_COLUMN,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    inPath: false,\r\n    inPathFirst: false,\r\n    inShortestPath: false,\r\n    direction: \"\",\r\n  };\r\n};\r\n\r\nconst getNewGridWithTargetChanged = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  newGrid[END_ROW][END_COLUMN].isFinish = false;\r\n  // newGrid[row][col].isWall = false;\r\n  newGrid[row][col].isFinish = true;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithSourceChanged = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  newGrid[START_ROW][START_COL].isStart = false;\r\n  // newGrid[row][col].isWall = false;\r\n  newGrid[row][col].isStart = true;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import './App.css';\nimport PathFinding from \"./PathFindingVisual/PathFinding\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div>\n        <PathFinding></PathFinding>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}